\section{Implementation}\label{sec:implementation}
We implemented JavaScript static analysis using dynamic shortcuts
presented in Section~\ref{sec:javascript} in a prototype implementation dubbed
$\tool$.  The tool is an extension of an existing state-of-the-art JavaScript
static analyzer SAFE~\cite{safe, safe2} with a dynamic analyzer
Jalangi~\cite{jalangi}, and it is an open-source project and available online~\footnote{The
URL of the tool is anonymized due to a double-blind review process.}.  In this
section, we introduce challenges and solutions in implementing dynamic
shortcuts on existing JavaScript analyzers.

\paragraph{Sealed Values.}
The main challenge of implementing dynamic shortcuts is to support sealed
symbolic execution on an existing JavaScript engine.  To represent an abstract
value, we use the \jscode{Proxy} object introduced in ECMAScript 6
(2015, ES6)~\cite{es6}, which allows developers to handle internal behaviors
of specific objects such as property reads and writes and implicit conversions.
We are inspired by \textsc{Mimic}~\cite{mimic}, which used \jscode{Proxy} to
capture accesses from internals of opaque functions.  When the dynamic analyzer
constructs an execution environment at the start of a dynamic shortcut, it
creates \jscode{Proxy} objects to represent abstract values via the
following \jscode{generateSymbol} function:
\begin{lstlisting}[style=myJSstyle]
function generateSymbol() {
  function detect() { /* access detection */ }
  return new Proxy(function() {}, {
    getPrototypeOf: detect,  ...
    construct     : detect
  }); }
var x = generateSymbol();
var y = x;
var z = x + 1;
\end{lstlisting}
The function creates a sealed symbol as a proxy object with a dummy
function object and a handler for all 13 traps using an access detection
function \jscode{detect}.  A sealed symbol invokes the function \jscode{detect}
when any of 13 pre-defined traps are operated on the object, which enables us to
determine whether an object is sealed or not.  For example, the variable
\jscode{y} successfully points to the same symbol stored in \jscode{x}, but the
program invokes the function \jscode{detect} on line 9 because \jscode{x + 1} requires
the actual value of the symbol.  In addition, we instrument unary and binary
operations in Jalangi so that we can detect all the accesses on the
symbol beyond the 13 traps provided by \jscode{Proxy}.
Using this idea, we successfully extended the
JavaScript engine to support sealed symbolic execution.

\paragraph{Synchronization of Control Points.}
For seamless interaction between static analysis and sealed symbolic execution,
synchronization of control points in both worlds is necessary.
The SAFE static analyzer parses a JavaScript program to an Abstract
Syntax Tree (AST), compiles it to its intermediate representation, and
builds a Control Flow Graph (CFG).  It produces annotations for
control points on CFGs including functions, call sites, and object allocation sites.
On the contrary, the Jalangi dynamic analyzer instruments a JavaScript program 
to keep track of necessary information at run time.  Therefore, during
sealed symbolic execution, Jalangi requires the annotations from SAFE to compute
abstract locations of newly created concrete objects and lexical environments.
The key to put annotations on the instrumented code is the source-code
location of the original AST node.  While both CFG of SAFE and
instrumented code of Jalangi maintain the source-code location information,
because they use different parsers we found various location mismatches for corner cases.
Therefore, we synchronize control points of two analyzers by using the closest match
of their source-code locations rather than using their exact match.

\paragraph{Function-Level Dynamic Shortcut.}
The dynamic shortcut is activated when the current abstract state passes the
filter $\checker$.  If the filter tolerantly admits the dynamic shortcut, the
analysis may suffer from the frequent communication between static and dynamic
analyzers.  To adjust the burden of communication, we only activate new
dynamic shortcut in function entries and deactivate it in the corresponding
function exits thus $\tool$ supports only \textit{function-level} dynamic
shortcut.

\paragraph{Termination.}
To guarantee the termination of static analysis using dynamic shortcuts, the
converter $\asconverter$ should pass an analysis element $(\view, \abselem)$
only when it terminates in a time bound $N$.  Since statically checking the
termination property is a difficult task, we simply perform sealed symbolic
execution with a pre-determined time limit.  When it times out,
we treat it as a failure in conversion;
otherwise, we use the result of sealed symbolic execution.  Our experiments used
5 seconds as the time limit for each sealed symbolic execution.


% \paragraph{Communication between Analyzers.}
% To perform dynamic shortcut, the static analyzer should communicate with the the
% dynamic analyzer by passing the current abstract state and receiving the final
% result of the sealed symbolic execution.  However, The static analyzer SAFE and
% the dynamic analyzer Jalangi are implemented in different languages Scala and
% JavaScript, respectively.  To overcome the difference, we represent abstract
% states as JSON objects and communicate between analyzers by passing them.  For
% each dynamic shortcut, Jalangi constructs the execution environments based on
% the given JSON object and executes the dynamic analysis from the target program
% points.  After finishing the sealed symbolic execution, it sends a newly
% constructed JSON object to SAFE to update the abstract states in the function
% exit point.


%\paragraph{Abstract Locations for Objects.}
%During dynamic analysis, each JavaScript object should be designated by the
%corresponding abstract location used in the static analysis.  In this paper, we
%define abstract locations using the allocation site
%abstraction~\cite{allocation-site} with heap cloning~\cite{heap-cloning} for
%each abstract context in the static analyzer.  Thus, we instrument the given
%JavaScript program to annotate each object created during dynamic analysis with
%its allocation site and context information.  After the sealed symbolic
%execution, the dynamic analyzer collects the objects based on their annotated
%information for each abstract location.


