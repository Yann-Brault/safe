\section{Proof of Theorem 1.4}\label{sec:proof}

We formally rephrase the meaning of Theorem~\ref{theorem:shortcut} in
Theorem~\ref{theorem:soundness} and Theorem~\ref{theorem:termination}.  Now, we
assume that the baseline sensitive abstract domain ensures the soundness and
termination, the sealed symbolic execution is valid, and the converter
$\asconverter: (\viewset \times \absdom) \hookrightarrow (\absimapset \times
\symbstset)$ satisfies the condition~\ref{equ:cond} in the
Theorem~\ref{theorem:shortcut}.


\subsection{Soundness}

\begin{theorem}[Soundness]\label{theorem:soundness}
  According to the equation~\ref{equ:sound}, the abstract interpretation using
  the combined domain $\combdom$ is \textit{sound} if and only if
  \begin{equation}\label{equ:comb-sound1}
    \forall \combelem_0, \combelem_1 \in \combdom. \; \combgamma(\combelem_0) \cup
    \combgamma(\combelem_1) \subseteq \combgamma(\combelem_0 \join \combelem_1)
  \end{equation}
  \begin{equation}\label{equ:comb-sound2}
    \forall \combelem \in \combdom. \; \step \circ \combgamma(\combelem) \subseteq
    \combgamma \circ \combstep(\combelem)\\
  \end{equation}
\end{theorem}
\begin{proof}
  First, we prove that the abstract transfer function $\abstransfer$ defined
  with the combined one-step execution $\combstep$ is sound
  \[
    \begin{array}{rcll}
      \transfer \circ \combgamma(\combelem)
      &=& \combgamma(\combelem) \cup \step \circ \combgamma(\combelem)\\
      &\subseteq& \combgamma(\combelem) \cup \combgamma \circ \combstep(\combelem)
      & (\because \; \text{Property~\ref{equ:comb-sound2}})\\
      &\subseteq& \combgamma(\combelem \join \combstep(\combelem))
      & (\because \; \text{Property~\ref{equ:comb-sound1}})\\
      &=& \combgamma \circ \abstransfer(\combelem)\\
    \end{array}
  \]
  Then, the abstract semantics $\abssem{\prog}$ is sound because it is defined
  with a sound abstract transfer function $\abstransfer$ using the combined
  one-step execution $\combstep$.
\end{proof}

First, we prove the Property~\ref{equ:comb-sound1} as follows:
\begin{lemma}
  \[
    \forall \combelem_0, \combelem_1 \in \combdom. \; \combgamma(\combelem_0) \cup
    \combgamma(\combelem_1) \subseteq \combgamma(\combelem_0 \join \combelem_1)
  \]
\end{lemma}
\begin{proof}
  \[
    \begin{array}{cl}
      \multicolumn{2}{l}{
        \combgamma((\sabselem, \symbelem)) \cup \combgamma((\sabselem', \symbelem'))
      }\\
      =& \sgamma(\sabselem) \cup \symbgamma(\symbelem)
      \cup \sgamma(\sabselem') \cup \symbgamma(\symbelem')\\
      =& (\sgamma(\sabselem)\cup \sgamma(\sabselem'))
      \cup (\symbgamma(\symbelem) \cup \symbgamma(\symbelem'))\\
      \subseteq& \sgamma(\sabselem \join \sabselem')
      \cup (\symbgamma(\symbelem) \cup \symbgamma(\symbelem'))\\
      & \multicolumn{1}{r}{(\because \; \sabsdom \; \text{is sound})}\\
      =& \sgamma(\sabselem \join \sabselem')
      \cup \symbgamma(\symbelem \cup \symbelem')\\
      =& \combgamma((\sabselem \join \sabselem', \symbelem \cup \symbelem'))\\
      =& \combgamma((\sabselem, \symbelem) \join (\sabselem', \symbelem'))\\
    \end{array}
  \]
\end{proof}

To prove Property~\ref{equ:comb-sound2}, we first prove the same property for
the sealed symbolic domain $\symbdom$ in Lemma~\ref{lemma:step-symb}.  Then, we
prove the properties of the $\triage$ function in Lemma~\ref{lemma:triage}.
Finally, we prove the Property~\ref{equ:comb-sound2} in
Lemma~\ref{lemma:comb-sound2}.

\begin{lemma}\label{lemma:step-symb}
  For a given set of pairs of abstract instantiation maps and sealed symbolic
  states $\symbelem \in \symbdom$, assume that the following condition is
  satisfied:
  \[
    \forall (\absimap, \symbst) \in \symbelem. \; \exists \symbst' \in
    \symbstset. \; \text{s.t.} \; \symbst \symbtrans \symbst'
  \]
  Then, the following property holds:
  \[
    \step \circ \symbgamma(\symbelem) \subseteq
    \symbgamma \circ \symbstep(\symbelem)\\
  \]
\end{lemma}
\begin{proof}
  \[
    \begin{array}{cl}
      \multicolumn{2}{l}{\step \circ \symbgamma(\symbelem)}\\
      =& \step(\bigcup \{ \instant{\symbst}{\absimap} \mid (\absimap, \symbst) \in
      \symbelem\})\\
      =& \{ \st' \mid (\absimap, \symbst) \in \symbelem \wedge \st \in
      \instant{\symbst}{\absimap} \wedge \st \trans \st'\})\\
      =& \{ \st' \mid (\absimap, \symbst) \in \symbelem \wedge \imap \in
      \imapgamma(\absimap) \wedge \instant{\symbst}{\imap} \trans \st'\})\\
      =& \{ \st' \mid (\absimap, \symbst) \in \symbelem \wedge \imap \in
      \imapgamma(\absimap) \wedge \instant{\symbst}{\imap} \trans \st'\\
       & \phantom{\{ \st' \mid (\absimap, \symbst) \in \symbelem \wedge \imap \in
      \imapgamma(\absimap)} \wedge \symbst \symbtrans \symbst' \})\\
      & \multicolumn{1}{r}{(\because \; \text{Assumption})}\\
      =& \{ \instant{\symbst'}{\imap} \mid (\absimap, \symbst)
      \in \symbelem \wedge \imap \in \imapgamma(\absimap) \wedge \symbst
      \symbtrans \symbst'\}\\
      & \multicolumn{1}{r}{(\because \; \text{Validity of} \; \symbtrans)}\\
      =& \bigcup \{ \instant{\symbst'}{\absimap} \mid (\absimap, \symbst)
      \in \symbelem \wedge \symbst \symbtrans \symbst' \}\\
      =& \symbgamma(\{ (\absimap, \symbst') \mid (\absimap, \symbst)
      \in \symbelem \wedge \symbst \symbtrans \symbst' \})\\
      =& \symbgamma \circ \symbstep(\symbelem)\\
    \end{array}
  \]
\end{proof}

\begin{lemma}\label{lemma:triage}
  For a given combined state $\combelem \in \combdom$, the $\triage$ function
  satisfies the following two properties:
  \begin{itemize}
    \item $\combgamma(\combelem) \subseteq \combgamma \circ \triage(\combelem)$
    \item $\forall (\absimap, \symbst) \in \symbelem. \; \exists \symbst' \in
      \symbstset.  \; \text{s.t.} \; \symbst \symbtrans \symbst'$
  \end{itemize}
  where $(\sabselem, \symbelem) = \triage(\combelem)$
\end{lemma}
\begin{proof}
  \[
    \fbox{$\combgamma(\combelem) \subseteq \combgamma \circ \triage(\combelem)$}
  \]
  \[
    \begin{array}{cl}
      \multicolumn{2}{l}{\combgamma((\sabselem, \symbelem))}\\
      =& \sgamma(\sabselem) \cup \symbgamma(\symbelem)\\

      =& \left( \underset{\view \in \viewset}{\bigcup} {\viewmap(\view) \cap
      \gamma \circ \sabselem(\view)} \right) \cup \left( \underset{(\absimap,
      \symbst) \in \symbelem}{\bigcup} \instant{\symbst}{\absimap} \right) \\

      =& \left( \underset{\view \in \viewset}{\bigcup} \aelemgamma((\view,
      \sabselem(\view))) \right) \cup \left( \underset{(\absimap, \symbst) \in
      \symbelem}{\bigcup} \aelemgamma((\absimap, \symbst)) \right) \\

      =& \dot\aelemgamma(\{ (\view, \sabselem(\view)) \mid \view \in \viewset \}
      \cup \symbelem)\\

      =& \dot\aelemgamma(\dot{\atriage}(\{ (\view, \sabselem(\view)) \mid \view
      \in \viewset \} \cup \symbelem))\\

       & \multicolumn{1}{r}{(\text{Trivially,} \; \forall \aelem \in \aelemset.
       \; \aelemgamma(\aelem) = \aelemgamma \circ \atriage(\aelem))}\\

      =& \dot\aelemgamma(E)\\
       & \multicolumn{1}{r}{(\text{See the definition of $E$ in
       Definition~\ref{def:triage}})}\\

      =& \left( \underset{(\view, \abselem) \in E}{\bigcup} \aelemgamma((\view,
      \abselem)) \right) \cup \left( \underset{(\absimap, \symbst) \in
    E}{\bigcup} \aelemgamma((\absimap, \symbst)) \right)\\

      =& \left( \underset{(\view, \abselem) \in E}{\bigcup} \viewmap(\view) \cap
      \gamma(\abselem) \right) \cup \left( \underset{(\absimap, \symbst) \in
      E}{\bigcup} \instant{\symbst}{\absimap} \right)\\

      =& \left( \underset{\view \in \viewset}{\bigcup} { \underset{(\view,
      \abselem) \in E}{\bigcup} \viewmap(\view) \cap \gamma(\abselem) } \right)
      \cup \left( \underset{(\absimap, \symbst) \in E}{\bigcup}
      \instant{\symbst}{\absimap} \right)\\

      =& \left( \underset{\view \in \viewset}{\bigcup} {\viewmap(\view) \cap
        \left(\underset{(\view, \abselem) \in
      E}{\bigcup}{\gamma(\abselem)}\right)} \right) \cup \left(
      \underset{(\absimap, \symbst) \in E}{\bigcup} \instant{\symbst}{\absimap}
      \right)\\

      \subseteq& \left( \underset{\view \in \viewset}{\bigcup} {\viewmap(\view)
        \cap \gamma\left( \underset{(\view, \abselem) \in E}{\bigjoin}\abselem
      \right)} \right) \cup \left( \underset{(\absimap, \symbst) \in E}{\bigcup}
      \instant{\symbst}{\absimap} \right)\\

      =& \sgamma\left( \lambda \view. \underset{(\view, \abselem) \in
      E}{\bigjoin}\abselem \right) \cup \symbgamma(E \cap (\absimapset \times
      \symbstset))\\

      =& \combgamma\left( \lambda \view. \underset{(\view, \abselem) \in
      E}{\bigjoin}\abselem, E \cap (\absimapset \times \symbstset) \right)\\

      =& \combgamma \circ \triage((\sabselem, \symbelem))\\
    \end{array}
  \]
  \[\]
  \[
    \fbox{$\forall (\absimap, \symbst) \in \symbelem. \; \exists \symbst' \in
    \symbstset.  \; \text{s.t.} \; \symbst \symbtrans \symbst'$}
  \]

  For a given $(\absimap, \symbst) \in \symbelem$, there exists an analysis
  element $\aelem \in \aelemset$ such that $\atriage(\aelem) = (\absimap,
  \symbst)$.  According to the definition of $\atriage$ in
  Definition~\ref{def:atriage}, there are two possible cases: $\aelem =
  (\absimap, \symbst) \wedge \exists \symbst' \in \symbstset. \; \text{s.t} \;
  \symbst \symbtrans \symbst'$ or $\aelem = (\view, \abselem) \wedge \aelem \in
  \Dom(\asconverter)$. We separately consider those two cases:
  \begin{itemize}
    \item $\aelem = (\absimap, \symbst) \wedge \exists \symbst' \in \symbstset.
      \; \text{s.t} \; \symbst \symbtrans \symbst'$\\
        By definition, $\exists \symbst' \in \symbstset.  \; \text{s.t} \;
        \symbst \symbtrans \symbst'$
    \item $\aelem = (\view, \abselem) \wedge \aelem \in \Dom(\asconverter)$\\
      By the condition~\ref{equ:cond} in the Theorem~\ref{theorem:shortcut},\\
      $\exists k > 1. \symbst \symbtrans^k \excst$.  Thus, $\exists \symbst' \in
      \symbstset.  \; \text{s.t} \; \symbst \symbtrans \symbst'$
  \end{itemize}
\end{proof}


\begin{lemma}\label{lemma:comb-sound2}
  \[
    \forall \combelem \in \combdom. \; \step \circ \combgamma(\combelem) \subseteq
    \combgamma \circ \combstep(\combelem)\\
  \]
\end{lemma}
\begin{proof}
  \[
    \begin{array}{cl}
      \multicolumn{2}{l}{
        \step \circ \combgamma(\combelem)
      }\\
      \subseteq& \step \circ \combgamma((\sabselem, \symbelem))\\
       & \multicolumn{1}{r}{(\because \; \text{First property in
       Lemma~\ref{lemma:triage}}}\\
       & \multicolumn{1}{r}{\text{where} \; (\sabselem, \symbelem)
       = \triage(\combelem).)}\\

      =& \step(\sgamma(\sabselem) \cup \symbgamma(\symbelem))\\
      =& \step(\sgamma(\sabselem)) \cup \step(\symbgamma(\symbelem))\\
      \subseteq& \sgamma \circ \sabsstep(\sabselem) \cup \step(\symbgamma(\symbelem))\\
      & \multicolumn{1}{r}{(\because \; \sabsdom \; \text{is sound.})}\\
      \subseteq& \sgamma \circ \sabsstep(\sabselem) \cup \symbgamma \circ
      \symbstep((\symbelem))\\
               & \multicolumn{1}{r}{(\because \; \text{Sceond property in
               Lemma~\ref{lemma:triage}} }\\
               & \multicolumn{1}{r}{\text{and Lemma~\ref{lemma:step-symb}})}\\
      =& \combgamma((\sabsstep(\sabselem), \symbstep(\symbelem)))\\
      =& \combgamma \circ \combstep(\combelem)\\

      % =& (\sgamma(\sabselem)\cup \sgamma(\sabselem'))
      % \cup (\symbgamma(\symbelem) \cup \symbgamma(\symbelem'))\\
      % \subseteq& \sgamma(\sabselem \join \sabselem')
      % \cup (\symbgamma(\symbelem) \cup \symbgamma(\symbelem'))\\
      % & \multicolumn{1}{r}{(\because \; \sabsdom \; \text{is sound.})}\\
      % =& \sgamma(\sabselem \join \sabselem')
      % \cup \symbgamma(\symbelem \cup \symbelem')\\
      % =& \combgamma((\sabselem \join \sabselem', \symbelem \cup \symbelem'))\\
      % =& \combgamma((\sabselem, \symbelem) \join (\sabselem', \symbelem'))\\
    \end{array}
  \]
\end{proof}

\subsection{Termination}

\begin{theorem}[Termination]\label{theorem:termination}
\end{theorem}























% Let's assume that $\viewmap$ partitions $\dom$, that is,
% there exists exactly one $\view\ s.t. \; \viewmap(\view)=\elem$
% for every $\elem \in \dom$.
% 
% \bigskip
% 
% Definition.
% \[
%   \combgamma(\combelem) = \{
%     \st \in \stset \mid
%     \symbst \in \combelem \wedge
%     \saconverter(\symbst) = (\view, \abselem) \wedge
%     \st \in \delta(\view) \wedge
%     \st \in \gamma(\abselem)
%   \}
% \]
% 
% Property of $\combgamma$:
% \[
%   \combgamma(\combelem_1 \cup \combelem_2) = \combgamma(\combelem_1) \cup \combgamma(\combelem_2)
% \]
% 
% \begin{proof}
% 
% \[
%   \begin{array}{rcl}
%     \st \in \combgamma(\combelem_1 \cup \combelem_2)
%     &\iff& \exists \symbst,\view,\abselem. \symbst \in (\combelem_1 \cup \combelem_2) \wedge
%       \saconverter(\symbst) = (\view, \abselem) \wedge
%       \st \in \delta(\view) \wedge
%       \st \in \gamma(\abselem) \\
%     &\iff& \exists \symbst,\view,\abselem. (\symbst \in \combelem_1 \lor \symbst \in \combelem_2) \wedge
%       \saconverter(\symbst) = (\view, \abselem) \wedge
%       \st \in \delta(\view) \wedge
%       \st \in \gamma(\abselem) \\
%     &\iff& \exists \symbst,\view,\abselem. \symbst \in \combelem_1 \wedge
%       \saconverter(\symbst) = (\view, \abselem) \wedge
%       \st \in \delta(\view) \wedge
%       \st \in \gamma(\abselem) \; \lor\\
%     && \symbst \in \combelem_2 \wedge
%       \saconverter(\symbst) = (\view, \abselem) \wedge
%       \st \in \delta(\view) \wedge
%       \st \in \gamma(\abselem) \\
%     &\iff& \exists \symbst,\view,\abselem. \symbst \in \combelem_1 \wedge
%       \saconverter(\symbst) = (\view, \abselem) \wedge
%       \st \in \delta(\view) \wedge
%       \st \in \gamma(\abselem) \; \lor \\
%     && \exists \symbst,\view,\abselem. \symbst \in \combelem_2 \wedge
%       \saconverter(\symbst) = (\view, \abselem) \wedge
%       \st \in \delta(\view) \wedge
%       \st \in \gamma(\abselem) \\
%     &\iff& \st \in \combgamma(\combelem_1) \lor \st \in \combgamma(\combelem_2) \\
%     &\iff& \st \in \combgamma(\combelem_1) \cup \combgamma(\combelem_2)
%   \end{array}
% \]
% \end{proof}
% 
% \begin{theorem}
%   The extended view transistion function satisfies the soundness condition:
%   
%   for all $\combelem$, $\view$ and $\view'$,
%   \[
%     \step(\combgamma(\combelem) \cap \viewmap(\view))
%     \cap \viewmap(\view') \subseteq \combgamma \circ
%     \combviewtrans{\view}{\view'}(\combelem)
%   \]
% \end{theorem}
% 
% \begin{proof}
% 
% Let's define
% 
% \[
%   \combviewtrans{\view}{\view'}_S(\combelem) = \{
%       \symbst' \mid \symbst \in \combelem \wedge
%       \saconverter(\symbst) = (\view, \_) \wedge
%       \symbst \symbtrans \symbst' \wedge
%       \saconverter(\symbst') = (\view', \_)
%     \}
% \]
% 
% and
% \[
%   \combviewtrans{\view}{\view'}_D(\combelem) = 
%   \left\{
%     \begin{array}{ll}
%       \{ \asconverter(\view', \viewtrans{\view}{\view'}(\bigjoin \{
%         \abselem \mid \symbst \in \combelem \wedge \saconverter(\symbst) = (\view, \abselem) \}) \}
%       & \text{if} \; \combelem \neq \varnothing\\
%       \varnothing & \text{otherwise}\\
%     \end{array}
%     \right.
% % \{
% %  \asconverter(\view', \viewtrans{\view}{\view'}(\bigjoin \{
% %    \abselem \mid \symbst \in \combelem \wedge \saconverter(\symbst) = (\view, \abselem) \}) \}
% \]
% 
% Then,
% \[
%   \combviewtrans{\view}{\view'}(\combelem) =
%   \combviewtrans{\view}{\view'}_S(S) \cup
%   \combviewtrans{\view}{\view'}_D(D)
% \]
% 
% \begin{lemma}
% \[
%   \step(\combgamma(\combelem) \cap \viewmap(\view))
%   \cap \viewmap(\view') \subseteq \combgamma \circ
%   \combviewtrans{\view}{\view'}_S(\combelem)
% \]
% \end{lemma}
% 
% \begin{proof}
% 
% Let
% \[
%   \combstep(\combelem) = \{
%       \symbst' \mid \symbst \in \combelem \wedge
%       \symbst \symbtrans \symbst'
%     \}
% \]
% 
% Note that 
% $\step \circ \combgamma \subseteq \combgamma \circ \combstep$
% by property of $\symbtrans$. (\todo)
% 
% \bigskip
% 
% Let $\combelem'$ be subset of $\combelem$ s.t.
% \[
%   \combelem' = \{
%       \symbst \in \combelem \mid
%       \saconverter(\symbst) = (\view, \_)
%     \}
% \]
% 
% Then,
% \[
%   \step (\combgamma (\combelem) \cap \viewmap(\view)) =
%   \step \circ \combgamma (\combelem') \subseteq
%   \combgamma \circ \combstep(\combelem') =
%   \combgamma \circ \combstep_\view(\combelem)
% \]
% 
% where $\combstep_\view(\combelem) = \{
%       \symbst' \mid \symbst \in \combelem \wedge
%       \saconverter(\symbst) = (\view, \_) \wedge
%       \symbst \symbtrans \symbst'
%     \}$.
% 
% \bigskip
% 
% Therefore,
% \[
%   \step (\combgamma (\combelem) \cap \viewmap(\view)) \subseteq
%   \combgamma \circ \combstep_\view(\combelem)
% \]
% 
% and
% \[
%   \step (\combgamma (\combelem) \cap \viewmap(\view)) \cap \viewmap(\view') \subseteq
%   \combgamma \circ \combstep_\view(\combelem) \cap \viewmap(\view') =
%   \combgamma \circ \combviewtrans{\view}{\view'}_S(\combelem)
% \]
% \end{proof}
% 
% \begin{lemma}
% \[
%   \step(\combgamma(\combelem) \cap \viewmap(\view))
%   \cap \viewmap(\view') \subseteq \combgamma \circ
%   \combviewtrans{\view}{\view'}_D(\combelem)
% \]
% \end{lemma}
% 
% \begin{proof}
% It is trivial if $\combelem$ is empty. (Both sides become empty set.)
% 
% Otherwise,
% let $A = \{ \abselem \mid \symbst \in \combelem \wedge \saconverter(\symbst) = (\view, \abselem) \}$,
% then
% \[
%   \begin{array}{rcl}
%     \combgamma \circ \combviewtrans{\view}{\view'}_D(\combelem)
%     &=& \{
%         \st \in \stset \mid
%         \symbst \in \combviewtrans{\view}{\view'}_D(\combelem) \wedge
%         \saconverter(\symbst) = (\view'', \abselem) \wedge
%         \st \in \delta(\view'') \wedge
%         \st \in \gamma(\abselem)
%         \}\\
%     &=& \{
%         \st \in \stset \mid
%         \saconverter( \asconverter(\view', \viewtrans{\view}{\view'}(\bigjoin A))) = (\view'', \abselem) \wedge
%         \st \in \delta(\view'') \wedge
%         \st \in \gamma(\abselem)
%         \}\\
%     &=& \{
%         \st \in \stset \mid
%         (\view', \viewtrans{\view}{\view'}(\bigjoin A)) = (\view'', \abselem) \wedge
%         \st \in \delta(\view'') \wedge
%         \st \in \gamma(\abselem)
%         \}\\
%     &=& \viewmap(\view') \cap \gamma(\viewtrans{\view}{\view'}(\bigjoin A) \})\\
%     &\supseteq& \step(\gamma(\bigjoin A )
%       \cap \viewmap(\view)) \cap \viewmap(\view') \qquad \text{by condition of} \viewtrans{\view}{\view'} \\
%  \end{array}
% \]
% 
% Therefore, it is enough to show that
% \[
%   \combgamma(\combelem) \cap \viewmap(\view) \subseteq
%   \gamma(\bigjoin A )
% \]
% 
% Then,
% \[
%   \begin{array}{rclr}
%     \combgamma(\combelem) \cap \viewmap(\view)
%     &=& \{
%           \st \in \stset \mid
%           \abselem \in A \wedge
%           \st \in \gamma(\abselem)
%         \} \\
%     &=& \underset{\abselem \in A}{\bigcup}{\gamma(\abselem)} \\
%     &\subseteq& \gamma(\underset{\abselem \in A}{\bigjoin}{\abselem})
%       & \text{by condition of $\gamma$ and $\join$} \\
%     &=& \gamma (\bigjoin A)
%   \end{array}
% \]
% 
% which is the desired result.
% \end{proof}
% 
% Now, we can prove the theorem using two lemmas.
% 
% \[
%   \begin{array}{rclr}
%     \step(\combgamma(\combelem) \cap \viewmap(\view)) \cap \viewmap(\view')
%     &=& \step(\combgamma(S \cup D) \cap \viewmap(\view)) \cap \viewmap(\view')\\
%     &=& \step(\combgamma(S) \cap \viewmap(\view)) \cap \viewmap(\view') \cup
%         \step(\combgamma(D) \cap \viewmap(\view)) \cap \viewmap(\view')\\
%     &\subseteq& \combgamma \circ \combviewtrans{\view}{\view'}_S(S) \cup
%         \step(\combgamma(D) \cap \viewmap(\view)) \cap \viewmap(\view') & \text{by Lemma1}\\
%     &\subseteq& \combgamma \circ \combviewtrans{\view}{\view'}_S(S) \cup
%         \combgamma \circ \combviewtrans{\view}{\view'}_D(D) & \text{by Lemma2}\\
%     &=& \combgamma(\combviewtrans{\view}{\view'}_S(S) \cup \combviewtrans{\view}{\view'}_D(D))\\
%     &=& \combgamma(\combviewtrans{\view}{\view'}(\combelem))
%   \end{array}
% \]
% 
% \end{proof}
% 
% \begin{theorem}
% \[
%   \step \circ \scombgamma \subseteq \scombgamma \circ \scombstep
% \]
% \end{theorem}
% 
% \begin{proof}
% Note that if $\viewmap$ is partition of $\dom$,
% \[
%   \begin{array}{rcl}
%     \scombgamma(\scombelem)
%     &=& \{ \st \in \stset \mid \forall \view \in \viewset. \;
%     \st \in \viewmap(\view) \Rightarrow \st \in \combgamma \circ \scombelem(\view) \}\\
%     &=& \underset{\view \in \viewset}{\bigcup}
%       {(\viewmap(\view) \cap \combgamma(\scombelem(\view)))}
%   \end{array}
% \]
% 
% Now,
% \[
%   \begin{array}{rclr}
%     \step(\scombgamma(\scombelem))
%     &=& \step(\underset{\view \in \viewset}{\bigcup}
%       {(\viewmap(\view) \cap \combgamma(\scombelem(\view)))})\\
%     &=& \underset{\view \in \viewset}{\bigcup}
%       {\step(\viewmap(\view) \cap \combgamma(\scombelem(\view)))}\\
%     &=& \underset{\view' \in \viewset}{\bigcup}
%       {(\viewmap(\view') \cap
%       \underset{\view \in \viewset}{\bigcup}
%         {(\step(\viewmap(\view) \cap \combgamma(\scombelem(\view))) \cap \viewmap(\view'))})}\\
%     &\subseteq& \underset{\view' \in \viewset}{\bigcup}
%       {(\viewmap(\view') \cap \underset{\view \in \viewset}{\bigcup}
%         {\combgamma \circ \combviewtrans{\view}{\view'} \circ \scombelem(\view)})} & \text{by Theorem 1}\\
%     &=& \underset{\view' \in \viewset}{\bigcup}{(\viewmap(\view') \cap
%       \combgamma(\underset{\view \in \viewset}{\bigcup}{\combviewtrans{\view}{\view'} \circ \scombelem(\view)}))} \\
%     &=& \underset{\view' \in \viewset}{\bigcup}{(\viewmap(\view') \cap
%       \combgamma(\scombstep(\scombelem)(\view'))}\\
%     &=& \scombgamma(\scombstep(\scombelem)) 
%  
%   \end{array}
% \]
% \end{proof}
% 
% $\todo$ : Termination proof?
% 
% \begin{comment}
% 
% Definition2
% \[
%   \combstep(\combelem) = \{
%     \symbst' \mid \symbst \in S \wedge
%     \symbst \symbtrans \symbst'
%     \}
%     \cup
%     (g \circ \sabsstep \circ f)(D)
% \]
% 
% where
% $S = \combelem\mid_{\checker}$ and
% $D = \combelem\mid_{\neg\checker}$
% and two domain converters
% $\combdom \galois{f}{g} \sabsdom$
% are defined as ...
% 
% \begin{theorem}
% \[
%   \step \circ \combgamma \subseteq \combgamma \circ \combstep
% \]
% \end{theorem}
% 
% Proof.
% 
% Let's define
% \[
%   \symbolic{\combstep}(\combelem) = \{
%     \symbst' \mid \symbst \in \combelem \wedge
%     \symbst \symbtrans \symbst'
%   \}
% \]
% 
% and
% \[
%   \abs{\combstep}(\combelem) = (g \circ \sabsstep \circ f)(\combelem)
% \]
% 
% then we can see that
% \[
%   \combstep(\combelem) = \symbolic{\combstep}(S) \cup \abs{\combstep}(D)
% \]
% 
% Lemma. 
% \[
%   \step \circ \combgamma \subseteq \combgamma \circ \abs{\combstep}
% \]
% 
% Proof of Lemma.
% 
% 
% 
% Then, 
% \[
%   \begin{array}{rcll}
%     \step\circ\combgamma(\combelem) &=& \step\circ\combgamma(S \cup D)\\
%     &=& \step\circ\combgamma(S)  \cup \step\circ\combgamma(D) & (by Definition of \step and \combgamma) (TODO)\\
%     &\subseteq& \combgamma\circ\symbolic{\combstep}(S) \cup \step\circ\combgamma(D) & (by property of \symbtrans)\\
%     &\subseteq& \combgamma\circ\symbolic{\combstep}(S) \cup \combgamma\circ\abs{\combstep}(D) & (by lemma)\\
%     &=& \combgamma(\symbolic{\combstep}(S) \cup \abs{\combstep}(D))\\
%     &=& \combgamma\circ\combstep(\combelem)\\
%   \end{array}
% \]
% 
% \end{comment}
