\section{Proof of Theorem 1.4}\label{sec:proof}

We formally rephrase the meaning of Theorem~\ref{theorem:shortcut} in
Theorem~\ref{theorem:soundness} and Theorem~\ref{theorem:termination}.  Now, we
assume that the baseline sensitive abstract domain ensures the soundness and
satisfies ascending chain condition, the sealed symbolic execution is valid,
and the converter $\asconverter: (\viewset \times \absdom) \hookrightarrow
(\absimapset \times \symbstset)$ satisfies the
condition~\ref{equ:cond} in the Theorem~\ref{theorem:shortcut}.


\subsection{Soundness}

\begin{theorem}[Soundness]\label{theorem:soundness}
  According to the equation~\ref{equ:sound}, the abstract interpretation using
  the combined domain $\combdom$ is \textit{sound} if and only if
  \begin{equation}\label{equ:comb-sound1}
    \forall \combelem_0, \combelem_1 \in \combdom. \; \combgamma(\combelem_0) \cup
    \combgamma(\combelem_1) \subseteq \combgamma(\combelem_0 \join \combelem_1)
  \end{equation}
  \begin{equation}\label{equ:comb-sound2}
    \forall \combelem \in \combdom. \; \step \circ \combgamma(\combelem) \subseteq
    \combgamma \circ \combstep(\combelem)\\
  \end{equation}
\end{theorem}
\begin{proof}
  First, we prove that the abstract transfer function $\combtransfer: \combdom
  \rightarrow \combdom$ defined as $\combtransfer(\combelem) = \combelem \join
  \combstep$ is sound
  \[
    \begin{array}{rcll}
      \transfer \circ \combgamma(\combelem)
      &=& \combgamma(\combelem) \cup \step \circ \combgamma(\combelem)\\
      &\subseteq& \combgamma(\combelem) \cup \combgamma \circ \combstep(\combelem)
      & (\because \; \text{Property~\ref{equ:comb-sound2}})\\
      &\subseteq& \combgamma(\combelem \join \combstep(\combelem))
      & (\because \; \text{Property~\ref{equ:comb-sound1}})\\
      &=& \combgamma \circ \combtransfer(\combelem)\\
    \end{array}
  \]
  Then, the abstract semantics $\abssem{\prog}$ is sound because it is defined
  with a sound abstract transfer function $\combtransfer$ using the combined
  one-step execution $\combstep$.
\end{proof}

First, we prove the Property~\ref{equ:comb-sound1} as follows:
\begin{lemma}
  \[
    \forall \combelem_0, \combelem_1 \in \combdom. \; \combgamma(\combelem_0) \cup
    \combgamma(\combelem_1) \subseteq \combgamma(\combelem_0 \join \combelem_1)
  \]
\end{lemma}
\begin{proof}
  \[
    \begin{array}{cl}
      \multicolumn{2}{l}{
        \combgamma((\sabselem, \symbelem)) \cup \combgamma((\sabselem', \symbelem'))
      }\\
      =& \sgamma(\sabselem) \cup \symbgamma(\symbelem)
      \cup \sgamma(\sabselem') \cup \symbgamma(\symbelem')\\
      =& (\sgamma(\sabselem)\cup \sgamma(\sabselem'))
      \cup (\symbgamma(\symbelem) \cup \symbgamma(\symbelem'))\\
      \subseteq& \sgamma(\sabselem \join \sabselem')
      \cup (\symbgamma(\symbelem) \cup \symbgamma(\symbelem'))\\
      & \multicolumn{1}{r}{(\because \; \sabsdom \; \text{is sound})}\\
      =& \sgamma(\sabselem \join \sabselem')
      \cup \symbgamma(\symbelem \cup \symbelem')\\
      =& \combgamma((\sabselem \join \sabselem', \symbelem \cup \symbelem'))\\
      =& \combgamma((\sabselem, \symbelem) \join (\sabselem', \symbelem'))\\
    \end{array}
  \]
\end{proof}

To prove Property~\ref{equ:comb-sound2}, we first prove the same property for
the sealed symbolic domain $\symbdom$ in Lemma~\ref{lemma:step-symb}.  Then, we
prove the properties of the $\reform$ function in Lemma~\ref{lemma:reform}.
Finally, we prove the Property~\ref{equ:comb-sound2} in
Lemma~\ref{lemma:comb-sound2}.

\begin{lemma}\label{lemma:step-symb}
  For a given set of pairs of abstract instantiation maps and sealed symbolic
  states $\symbelem \in \symbdom$, assume that the following condition is
  satisfied:
  \[
    \forall (\absimap, \symbst) \in \symbelem. \; \exists \symbst' \in
    \symbstset. \; \text{s.t.} \; \symbst \symbtrans \symbst'
  \]
  Then, the following property holds:
  \[
    \step \circ \symbgamma(\symbelem) \subseteq
    \symbgamma \circ \symbstep(\symbelem)\\
  \]
\end{lemma}
\begin{proof}
  \[
    \begin{array}{cl}
      \multicolumn{2}{l}{\step \circ \symbgamma(\symbelem)}\\
      =& \step(\bigcup \{ \instant{\symbst}{\absimap} \mid (\absimap, \symbst) \in
      \symbelem\})\\
      =& \{ \st' \mid (\absimap, \symbst) \in \symbelem \wedge \st \in
      \instant{\symbst}{\absimap} \wedge \st \trans \st'\})\\
      =& \{ \st' \mid (\absimap, \symbst) \in \symbelem \wedge \imap \in
      \imapgamma(\absimap) \wedge \instant{\symbst}{\imap} \trans \st'\})\\
      =& \{ \st' \mid (\absimap, \symbst) \in \symbelem \wedge \imap \in
      \imapgamma(\absimap) \wedge \instant{\symbst}{\imap} \trans \st'\\
       & \phantom{\{ \st' \mid (\absimap, \symbst) \in \symbelem \wedge \imap \in
      \imapgamma(\absimap)} \wedge \symbst \symbtrans \symbst' \})\\
      & \multicolumn{1}{r}{(\because \; \text{Assumption})}\\
      =& \{ \instant{\symbst'}{\imap} \mid (\absimap, \symbst)
      \in \symbelem \wedge \imap \in \imapgamma(\absimap) \wedge \symbst
      \symbtrans \symbst'\}\\
      & \multicolumn{1}{r}{(\because \; \text{Validity of} \; \symbtrans)}\\
      =& \bigcup \{ \instant{\symbst'}{\absimap} \mid (\absimap, \symbst)
      \in \symbelem \wedge \symbst \symbtrans \symbst' \}\\
      =& \symbgamma(\{ (\absimap, \symbst') \mid (\absimap, \symbst)
      \in \symbelem \wedge \symbst \symbtrans \symbst' \})\\
      =& \symbgamma \circ \symbstep(\symbelem)\\
    \end{array}
  \]
\end{proof}

\begin{lemma}\label{lemma:reform}
  For a given combined state $\combelem \in \combdom$, the $\reform$ function
  satisfies the following two properties:
  \begin{itemize}
    \item $\combgamma(\combelem) \subseteq \combgamma \circ \reform(\combelem)$
    \item $\forall (\absimap, \symbst) \in \symbelem. \; \exists \symbst' \in
      \symbstset.  \; \text{s.t.} \; \symbst \symbtrans \symbst'$
  \end{itemize}
  where $(\sabselem, \symbelem) = \reform(\combelem)$
\end{lemma}
\begin{proof}
  \[
    \fbox{$\combgamma(\combelem) \subseteq \combgamma \circ \reform(\combelem)$}
  \]
  \[
    \begin{array}{cl}
      \multicolumn{2}{l}{\combgamma((\sabselem, \symbelem))}\\
      =& \sgamma(\sabselem) \cup \symbgamma(\symbelem)\\

      =& \left( \underset{\view \in \viewset}{\bigcup} {\viewmap(\view) \cap
      \gamma \circ \sabselem(\view)} \right) \cup \left( \underset{(\absimap,
      \symbst) \in \symbelem}{\bigcup} \instant{\symbst}{\absimap} \right) \\

      =& \left( \underset{\view \in \viewset}{\bigcup} \aelemgamma((\view,
      \sabselem(\view))) \right) \cup \left( \underset{(\absimap, \symbst) \in
      \symbelem}{\bigcup} \aelemgamma((\absimap, \symbst)) \right) \\

      =& \dot\aelemgamma(\{ (\view, \sabselem(\view)) \mid \view \in \viewset \}
      \cup \symbelem)\\

      =& \dot\aelemgamma(\dot{\areform}(\{ (\view, \sabselem(\view)) \mid \view
      \in \viewset \} \cup \symbelem))\\

       & \multicolumn{1}{r}{(\text{Trivially,} \; \forall \aelem \in \aelemset.
       \; \aelemgamma(\aelem) = \aelemgamma \circ \areform(\aelem))}\\

      =& \dot\aelemgamma(E)\\
       & \multicolumn{1}{r}{(\text{See the definition of $E$ in
       Definition~\ref{def:reform}})}\\

      =& \left( \underset{(\view, \abselem) \in E}{\bigcup} \aelemgamma((\view,
      \abselem)) \right) \cup \left( \underset{(\absimap, \symbst) \in
    E}{\bigcup} \aelemgamma((\absimap, \symbst)) \right)\\

      =& \left( \underset{(\view, \abselem) \in E}{\bigcup} \viewmap(\view) \cap
      \gamma(\abselem) \right) \cup \left( \underset{(\absimap, \symbst) \in
      E}{\bigcup} \instant{\symbst}{\absimap} \right)\\

      =& \left( \underset{\view \in \viewset}{\bigcup} { \underset{(\view,
      \abselem) \in E}{\bigcup} \viewmap(\view) \cap \gamma(\abselem) } \right)
      \cup \left( \underset{(\absimap, \symbst) \in E}{\bigcup}
      \instant{\symbst}{\absimap} \right)\\

      =& \left( \underset{\view \in \viewset}{\bigcup} {\viewmap(\view) \cap
        \left(\underset{(\view, \abselem) \in
      E}{\bigcup}{\gamma(\abselem)}\right)} \right) \cup \left(
      \underset{(\absimap, \symbst) \in E}{\bigcup} \instant{\symbst}{\absimap}
      \right)\\

      \subseteq& \left( \underset{\view \in \viewset}{\bigcup} {\viewmap(\view)
        \cap \gamma\left( \underset{(\view, \abselem) \in E}{\bigjoin}\abselem
      \right)} \right) \cup \left( \underset{(\absimap, \symbst) \in E}{\bigcup}
      \instant{\symbst}{\absimap} \right)\\

      =& \sgamma\left( \lambda \view. \underset{(\view, \abselem) \in
      E}{\bigjoin}\abselem \right) \cup \symbgamma(E \cap (\absimapset \times
      \symbstset))\\

      =& \combgamma\left( \lambda \view. \underset{(\view, \abselem) \in
      E}{\bigjoin}\abselem, E \cap (\absimapset \times \symbstset) \right)\\

      =& \combgamma \circ \reform((\sabselem, \symbelem))\\
    \end{array}
  \]
  \[\]
  \[
    \fbox{$\forall (\absimap, \symbst) \in \symbelem. \; \exists \symbst' \in
    \symbstset.  \; \text{s.t.} \; \symbst \symbtrans \symbst'$}
  \]

  For a given $(\absimap, \symbst) \in \symbelem$, there exists an analysis
  element $\aelem \in \aelemset$ such that $\areform(\aelem) = (\absimap,
  \symbst)$.  According to the definition of $\areform$ in
  Definition~\ref{def:areform}, there are two possible cases: $\aelem =
  (\absimap, \symbst) \wedge \exists \symbst' \in \symbstset. \; \text{s.t} \;
  \symbst \symbtrans \symbst'$ or $\aelem = (\view, \abselem) \wedge \aelem \in
  \Dom(\asconverter)$. We separately consider those two cases:
  \begin{itemize}
    \item $\aelem = (\absimap, \symbst) \wedge \exists \symbst' \in \symbstset.
      \; \text{s.t} \; \symbst \symbtrans \symbst'$\\
        By definition, $\exists \symbst' \in \symbstset.  \; \text{s.t} \;
        \symbst \symbtrans \symbst'$
    \item $\aelem = (\view, \abselem) \wedge \aelem \in \Dom(\asconverter)$\\
      By the condition~\ref{equ:cond} in the Theorem~\ref{theorem:shortcut},\\
      $\exists k > 1. \symbst \symbtrans^k \excst$.  Thus, $\exists \symbst' \in
      \symbstset.  \; \text{s.t} \; \symbst \symbtrans \symbst'$
  \end{itemize}
\end{proof}


\begin{lemma}\label{lemma:comb-sound2}
  \[
    \forall \combelem \in \combdom. \; \step \circ \combgamma(\combelem) \subseteq
    \combgamma \circ \combstep(\combelem)\\
  \]
\end{lemma}
\begin{proof}
  \[
    \begin{array}{cl}
      \multicolumn{2}{l}{
        \step \circ \combgamma(\combelem)
      }\\
      \subseteq& \step \circ \combgamma((\sabselem, \symbelem))\\
       & \multicolumn{1}{r}{(\because \; \text{First property in
       Lemma~\ref{lemma:reform}}}\\
       & \multicolumn{1}{r}{\text{where} \; (\sabselem, \symbelem)
       = \reform(\combelem).)}\\

      =& \step(\sgamma(\sabselem) \cup \symbgamma(\symbelem))\\
      =& \step(\sgamma(\sabselem)) \cup \step(\symbgamma(\symbelem))\\
      \subseteq& \sgamma \circ \sabsstep(\sabselem) \cup \step(\symbgamma(\symbelem))\\
      & \multicolumn{1}{r}{(\because \; \sabsdom \; \text{is sound.})}\\
      \subseteq& \sgamma \circ \sabsstep(\sabselem) \cup \symbgamma \circ
      \symbstep((\symbelem))\\
               & \multicolumn{1}{r}{(\because \; \text{Sceond property in
               Lemma~\ref{lemma:reform}} }\\
               & \multicolumn{1}{r}{\text{and Lemma~\ref{lemma:step-symb}})}\\
      =& \combgamma((\sabsstep(\sabselem), \symbstep(\symbelem)))\\
      =& \combgamma \circ \combstep(\combelem)\\

      % =& (\sgamma(\sabselem)\cup \sgamma(\sabselem'))
      % \cup (\symbgamma(\symbelem) \cup \symbgamma(\symbelem'))\\
      % \subseteq& \sgamma(\sabselem \join \sabselem')
      % \cup (\symbgamma(\symbelem) \cup \symbgamma(\symbelem'))\\
      % & \multicolumn{1}{r}{(\because \; \sabsdom \; \text{is sound.})}\\
      % =& \sgamma(\sabselem \join \sabselem')
      % \cup \symbgamma(\symbelem \cup \symbelem')\\
      % =& \combgamma((\sabselem \join \sabselem', \symbelem \cup \symbelem'))\\
      % =& \combgamma((\sabselem, \symbelem) \join (\sabselem', \symbelem'))\\
    \end{array}
  \]
\end{proof}

\subsection{Termination}

First, let's define some notations.

\begin{itemize}
\item
Let's define initial state of combined domain as follows:
\[
  \icombelem = (\isabselem, \emptyset)
\]
\item
Let's define $\combelem^i$, $\sabselem^i$, and $\symbelem^i$ for $i \geq 0$ as follows:
\[
  \combelem^i = (\sabselem^i, \symbelem^i) = \combtransfer^i(\icombelem)
\]
which means resulting state after applying transfer function $\combtransfer \; i$ times.
\item
Let's define the lifted symbolic transition relation
$\liftsymbtrans \subseteq
(\absimapset \times \symbstset) \times (\absimapset \times \symbstset)$
as follows:
\[
  (\absimap, \symbst) \liftsymbtrans (\absimap, \symbst') \Leftrightarrow
  \symbst \symbtrans \symbst'
\]
\end{itemize}

\begin{theorem}[Termination]\label{theorem:termination}
  \[
    \exists n \in \numset. \forall m \geq n. \;
    \combelem^m = \combelem^n
  \]
\end{theorem}

We prove this theorem after proving a series of lemmas.
We first begin by showing that sensitive abstract interpretation terminates in
finite time.

\begin{lemma}[Termination of sensitive abstract interpretation]\label{lemma:sabs-term}
\label{theorem:sabs-termination}
  \[
    \exists n. \; \forall m \geq n. \;
    \sabselem^m = \sabselem^n
  \]
\end{lemma}

\begin{proof}
Note that for all $\sabselem, \sabselem' \in \sabsdom$ that satisfies
$\combtransfer((\sabselem, \_)) = (\sabselem', \_)$,
\[
  \begin{array}{rcl}
  \combtransfer((\sabselem, \_))
  &=& (\sabselem, \_) \join \combstep((\sabselem, \_))\\
  &=& (\sabselem, \_) \join (\_, \_) = (\sabselem \join \_, \_)\\
  &=& (\sabselem', \_)
  \end{array}
\]

which implies $\sabselem \order \sabselem'$.

Now, since $\combtransfer((\sabselem^i, \_)) = (\sabselem^{i+1}, \_),
\sabselem^i \order \sabselem^{i+1}$ holds for all $i$.
Then, $\sabselem^0 \order \sabselem^1 \order \sabselem^2 ...$ is an ascending chain.
By ascending chain condition, there exists n such that
for all $m \geq n, \sabselem^m = \sabselem^n$.
\end{proof}

Now, let's show that sealed static symbolic execution does terminate
given that sensitive abstract interpretation terminates.

We begin by defining the difference set $\diffset_i \in \symbdom$ for $i \geq 0$ as follows:
\[
  \diffset_i = \symbelem^{i+1} \setminus \symbelem^i
\]

For simplicity, we define $\diffset_i$ as $\emptyset$ for $i < 0$.
Then we prove its properties:
\begin{lemma}[Property of difference set]\label{lemma:diffset_prop}
  \[
    \begin{array}{c}
      \forall i \geq 0. \; \forall \symbaelem \in \diffset_i. \\
      \exists \view. \; \asconverter((\view,\sabselem^i(\view))) \liftsymbtrans \symbaelem 
      \lor \exists \symbaelem' \in \diffset_{i-1} . \; \symbaelem' \liftsymbtrans \symbaelem
    \end{array}
  \]
\end{lemma}
\begin{proof}
  Let $i \in \numset$ and $\symbaelem \in \diffset_i = \symbelem^{i+1} \setminus \symbelem^i$ given.
  By definition,
  \[
    \symbelem^{i+1} = \symbelem^i \cup \symbstep({\symbelem^i}')
  \]
  where
  \[
    (\_, {\symbelem^i}') = \reform(\sabselem^i, \symbelem^i)
  \]
  Note that $\symbaelem \in \symbstep({\symbelem^i}')$,
  and by definition of $\symbstep$, there exists some
  $\symbaelem' \in {\symbelem^i}'$ that satisfies $\symbaelem' \liftsymbtrans \symbaelem$.
  Now, by definition of $\reform$,
  \[
    {\symbelem^i}' =
    \dot{\areform}(\{ (\view, \sabselem^i(\view)) \mid \view \in \viewset \} \cup \symbelem^i)
    \cap (\absimapset \times \symbstset)
  \]
  This means there exists
  $\aelem \in \{ (\view, \sabselem^i(\view)) \mid \view \in \viewset \} \cup \symbelem^i$
  that satisfies $\areform(\aelem) = \symbaelem'$. We have two possible cases for $\aelem$.
  \begin{itemize}
 
  \item $\aelem \in \{ (\view, \sabselem^i(\view)) \mid \view \in \viewset \}$

  In this case, $\areform(\aelem) = \asconverter(\aelem) = \symbaelem'$
  and the left condition for conclusion is satisfied.
  
  \item $\aelem \in \symbelem^i$

  In this case, $\areform(\aelem) = \aelem = \symbaelem'$.
  Now, let's assume that $\aelem \in \symbelem^{i-1}$.
  In that case, $\aelem$ would be preserved after reform step, that is,
  $\aelem \in {\symbelem^{i-1}}'$. Then, by definition of $\symbstep$,
  $\symbaelem \in \symbstep({\symbelem^{i-1}}') \subseteq \symbelem^i$
  whcih contradicts to the fact that $\symbaelem \in \diffset_i$.
  Therefore, $\aelem \notin \symbelem^{i-1}$, that is,
  $\aelem \in \symbelem^i \setminus \symbelem^{i-1} = \diffset_i$,
  and the right condition for conclusion is satisfied.
  \end{itemize}
\end{proof}

\begin{corollary}\label{corollary:only-from-diffset}
  \[
    \begin{array}{c}
      \forall i > 0. \; \sabselem^{i-1} = \sabselem^i \Rightarrow
      \forall \symbaelem \in \diffset_i. \\
      \exists \symbaelem' \in \diffset_{i-1} . \; \symbaelem' \liftsymbtrans \symbaelem
    \end{array}
  \]
\end{corollary}
\begin{proof}
  The proof goes same as the previous lemma, until the point where we divide
  the case for $\aelem$. Let's assume that the first case holds, that is,
  \[
    \aelem \in \{ (\view, \sabselem^i(\view)) \mid \view \in \viewset \}
  \]
  Since $\sabselem^{i-1} = \sabselem^i$,
  \[
    \aelem \in \{ (\view, \sabselem^{i-1}(\view)) \mid \view \in \viewset \}
  \]
  In that case, $\aelem$ would be transformed after reform step, that is,
  $\asconverter(\aelem) = \symbaelem' \in {\symbelem^{i-1}}'$.
  Then, by definition of $\symbstep$,
  $\symbaelem \in \symbstep({\symbelem^{i-1}}') \subseteq \symbelem^i$
  whcih contradicts to the fact that $\symbaelem \in \diffset_i$.
  Therefore, only second case holds and the right conclusion in previus lemma is satisfied.
\end{proof}

Now, we can define the TTL(time to live) function
$\ttl_i: \diffset_i \rightarrow \numset$ for $i \geq 0$ as follows:
\begin{definition}[TTL Function]
  \[
    \begin{array}{c} 
      \ttl_i(\symbaelem) = \left \{
      \begin{array}{l}
        N - 1 \;\; ( \text{if} \; D = \emptyset)\\
        \text{min}(\dot\ttl_{i-1}(D)) - 1
        \;\; ( \text{otherwise})
      \end{array}
      \right. \\
      \\
      \text{where} \; D = 
      \{\symbaelem' \in \diffset_{i-1} \mid \symbaelem' \liftsymbtrans \symbaelem\}
    \end{array}
  \]
\end{definition}

We prove following properties of TTL function.
\begin{lemma}
  \[
    \begin{array}{c}
      \forall i \geq 0. \; \forall \symbaelem \in \diffset_i.
      \ttl_i(\symbaelem) = k \Rightarrow \\
      k < N \wedge
      \exists (\view, \abselem). \; (\asconverter((\view,\abselem))
      \liftsymbtrans^{(N - k)} \symbaelem) \\
    \end{array}
  \]
\end{lemma}
\begin{proof}
  We prove by induction on $i$.
  Let $\symbaelem \in \diffset_i$.
  \begin{itemize}
  \item If $i = 0$, $\ttl_0(\symbaelem) = N - 1 < N$
  and since only left conclusion of lemma~\ref{lemma:diffset_prop} can hold,
  there eixsts view $\view$ s.t.
  $\asconverter(\view, \sabselem^0(\view)) \liftsymbtrans^1 \symbaelem$.
  \item If $i > 0$, we have two cases for $D = 
    \{\symbaelem' \in \diffset_{i-1} \mid \symbaelem' \liftsymbtrans \symbaelem\}$.
  If $D = \emptyset$, the argument is similar as $i = 0$ case.
  Otherwise, let $\symbaelem' = \underset{\x \in D}{argmin}{\ttl_{i-1}(x)}$.
  
  By induction hypothesis, we have
  \[
    k' = \ttl_{i-1}(\symbaelem') < N
  \]
  and there eixsts $(\view, \abselem)$ such that
  \[
    \symbaelem'' = \asconverter((\view,\abselem)) \liftsymbtrans^{(N - k')} \symbaelem'.
  \]
  By definition of $\ttl_i$,
  $\ttl_i(\symbaelem) = \ttl_i(\symbaelem') - 1$, and $k = k' - 1$.
  Then,
  \[
    k = k' - 1 < N - 1 < N
  \]
  and
  $\symbaelem'' \liftsymbtrans^{(N - k - 1)} \symbaelem'$ with
  $\symbaelem' \liftsymbtrans \symbaelem$ implies that
  \[
    \symbaelem'' \liftsymbtrans^{(N - k)} \symbaelem.
  \]
  \end{itemize}
\end{proof}
\begin{corollary}\label{corollary:ttl-range}
  \[
    \forall i \geq 0. \; \forall \symbaelem \in \diffset_i. \;
    0 < \ttl_i(\symbaelem) < N
  \]
\end{corollary}
\begin{proof}
We already proved $k = \ttl_i(\symbaelem) < N$.
Now, let's assume that $k \leq 0$.
By previous lemma, there exists $(\view, \abselem)$ such that
\[
  (\asconverter((\view,\abselem)) \liftsymbtrans^{(N - k)} \symbaelem)
\]
Since $N - k \geq N$, this implies that there exists $\symbaelem'$ such that
\[
  (\asconverter((\view,\abselem)) \liftsymbtrans^N \symbaelem')
\]
However, this contradicts to the condition of $\asconverter$ that says
if $(\view,\abselem)$ is in domain of $\asconverter$,
the number of possible $\symbtrans$ starting from state of $\asconverter((\view,\abselem))$
is at most N - 1.
Therefore, k > 0.
\end{proof}

\begin{lemma}\label{lemma:ttl-decr}
  \[
    \begin{array}{c}
      \forall i > 0. \; \sabselem^{i-1} = \sabselem^i \Rightarrow \\
      sup(\dot \ttl_i(\diffset_i)) \leq sup(\dot \ttl_{i-1}(\diffset_{i-1})) - 1
    \end{array}
  \]
\end{lemma}
\begin{proof}
  Let $\symbaelem \in \diffset_i$.
  By Corollary~\ref{corollary:only-from-diffset}, the set
  \[
    D = \{\symbaelem' \in \diffset_{i-1} \mid \symbaelem' \liftsymbtrans \symbaelem\}
  \]
  is non-empty, and for some $\symbaelem' \in \diffset_{i-1}$,
  \[
    \ttl_i(\symbaelem) = \ttl_{i-1}(\symbaelem') - 1 \leq sup(\dot \ttl_{i-1}(\diffset_{i-1})) - 1
  \]
  Since it holds for every $\symbaelem \in \diffset_i$,
  \[
    sup(\dot \ttl_i(\diffset_i)) \leq sup(\dot \ttl_{i-1}(\diffset_{i-1})) - 1
  \]
\end{proof}

Now, we can complete the proof of the Theorem~\ref{theorem:termination}.

\begin{proof}
By Lemma~\ref{lemma:sabs-term}, there exists $n \in \numset$ such that
for all $m \geq n$,
\[
  \sabselem^m = \sabselem^n
\]
By Corollary~\ref{corollary:ttl-range},
\[
  sup(\dot \ttl_n(\diffset_n)) < N.
\]
Now, by Lemma~\ref{lemma:ttl-decr}, for all $i>0$,
\[
  sup(\dot \ttl_{n+i}(\diffset_{n+i})) \leq sup(\dot \ttl_{n+i-1}(\diffset_{n+i-1})) - 1
\]
which implies that
\[
  sup(\dot \ttl_{n+i}(\diffset_{n+i})) \leq sup(\dot \ttl_n(\diffset_n)) - i < N - i
\]
Therefore, for $j \geq N$,
\[
  sup(\dot \ttl_{n+j}(\diffset_{n+j})) < N - j \leq 0
\]
Notice that again by Corollary~\ref{corollary:ttl-range},
\[
  inf(\dot \ttl_{n+j}(\diffset_{n+j})) > 0
\]
meaning that
\[
  inf(\dot \ttl_{n+j}(\diffset_{n+j})) > sup(\dot \ttl_{n+j}(\diffset_{n+j}))
\]
which implies $\diffset_{n+j} = \emptyset$ and
$\symbelem^{n+j+1} = \symbelem^{n+j}$.

Therefore, for all $m \geq n + N$,
\[
  \sabselem^m = \sabselem^n \wedge \symbelem^m = \symbelem^n
\]
and
\[
  \combelem^m = \combelem^n
\]

\end{proof}
