\section{Proof of Theorem 1.4}\label{sec:proof}

We formally rephrase the meaning of Theorem~\ref{theorem:shortcut} in
Theorem~\ref{theorem:soundness} and Theorem~\ref{theorem:termination}.  Now, we
assume that the baseline sensitive abstract domain ensures the soundness and
satisfies ascending chain condition, the sealed symbolic execution is valid,
and the converter $\asconverter: (\viewset \times \absdom) \hookrightarrow
(\absimapset \times \symbstset)$ satisfies the
condition~\ref{equ:cond} in the Theorem~\ref{theorem:shortcut}.


\subsection{Soundness}

\begin{theorem}[Soundness]\label{theorem:soundness}
  According to the equation~\ref{equ:sound}, the abstract interpretation using
  the combined domain $\combdom$ is \textit{sound} if and only if
  \begin{equation}\label{equ:comb-sound1}
    \forall \combelem_0, \combelem_1 \in \combdom. \; \combgamma(\combelem_0) \cup
    \combgamma(\combelem_1) \subseteq \combgamma(\combelem_0 \join \combelem_1)
  \end{equation}
  \begin{equation}\label{equ:comb-sound2}
    \forall \combelem \in \combdom. \; \step \circ \combgamma(\combelem) \subseteq
    \combgamma \circ \combstep(\combelem)\\
  \end{equation}
\end{theorem}
\begin{proof}
  First, we prove that the abstract transfer function $\combtransfer: \combdom
  \rightarrow \combdom$ defined as $\combtransfer(\combelem) = \combelem \join
  \combstep$ is sound
  \[
    \begin{array}{rcll}
      \transfer \circ \combgamma(\combelem)
      &=& \combgamma(\combelem) \cup \step \circ \combgamma(\combelem)\\
      &\subseteq& \combgamma(\combelem) \cup \combgamma \circ \combstep(\combelem)
      & (\because \; \text{Property~\ref{equ:comb-sound2}})\\
      &\subseteq& \combgamma(\combelem \join \combstep(\combelem))
      & (\because \; \text{Property~\ref{equ:comb-sound1}})\\
      &=& \combgamma \circ \combtransfer(\combelem)\\
    \end{array}
  \]
  Then, the abstract semantics $\abssem{\prog}$ is sound because it is defined
  with a sound abstract transfer function $\combtransfer$ using the combined
  one-step execution $\combstep$.
\end{proof}

First, we prove the Property~\ref{equ:comb-sound1} as follows:
\begin{lemma}
  \[
    \forall \combelem_0, \combelem_1 \in \combdom. \; \combgamma(\combelem_0) \cup
    \combgamma(\combelem_1) \subseteq \combgamma(\combelem_0 \join \combelem_1)
  \]
\end{lemma}
\begin{proof}
  \[
    \begin{array}{cl}
      \multicolumn{2}{l}{
        \combgamma((\sabselem, \symbelem)) \cup \combgamma((\sabselem', \symbelem'))
      }\\
      =& \sgamma(\sabselem) \cup \symbgamma(\symbelem)
      \cup \sgamma(\sabselem') \cup \symbgamma(\symbelem')\\
      =& (\sgamma(\sabselem)\cup \sgamma(\sabselem'))
      \cup (\symbgamma(\symbelem) \cup \symbgamma(\symbelem'))\\
      \subseteq& \sgamma(\sabselem \join \sabselem')
      \cup (\symbgamma(\symbelem) \cup \symbgamma(\symbelem'))\\
      & \multicolumn{1}{r}{(\because \; \sabsdom \; \text{is sound})}\\
      =& \sgamma(\sabselem \join \sabselem')
      \cup \symbgamma(\symbelem \cup \symbelem')\\
      =& \combgamma((\sabselem \join \sabselem', \symbelem \cup \symbelem'))\\
      =& \combgamma((\sabselem, \symbelem) \join (\sabselem', \symbelem'))\\
    \end{array}
  \]
\end{proof}

To prove Property~\ref{equ:comb-sound2}, we first prove the same property for
the sealed symbolic domain $\symbdom$ in Lemma~\ref{lemma:step-symb}.  Then, we
prove the properties of the $\triage$ function in Lemma~\ref{lemma:triage}.
Finally, we prove the Property~\ref{equ:comb-sound2} in
Lemma~\ref{lemma:comb-sound2}.

\begin{lemma}\label{lemma:step-symb}
  For a given set of pairs of abstract instantiation maps and sealed symbolic
  states $\symbelem \in \symbdom$, assume that the following condition is
  satisfied:
  \[
    \forall (\absimap, \symbst) \in \symbelem. \; \exists \symbst' \in
    \symbstset. \; \text{s.t.} \; \symbst \symbtrans \symbst'
  \]
  Then, the following property holds:
  \[
    \step \circ \symbgamma(\symbelem) \subseteq
    \symbgamma \circ \symbstep(\symbelem)\\
  \]
\end{lemma}
\begin{proof}
  \[
    \begin{array}{cl}
      \multicolumn{2}{l}{\step \circ \symbgamma(\symbelem)}\\
      =& \step(\bigcup \{ \instant{\symbst}{\absimap} \mid (\absimap, \symbst) \in
      \symbelem\})\\
      =& \{ \st' \mid (\absimap, \symbst) \in \symbelem \wedge \st \in
      \instant{\symbst}{\absimap} \wedge \st \trans \st'\})\\
      =& \{ \st' \mid (\absimap, \symbst) \in \symbelem \wedge \imap \in
      \imapgamma(\absimap) \wedge \instant{\symbst}{\imap} \trans \st'\})\\
      =& \{ \st' \mid (\absimap, \symbst) \in \symbelem \wedge \imap \in
      \imapgamma(\absimap) \wedge \instant{\symbst}{\imap} \trans \st'\\
       & \phantom{\{ \st' \mid (\absimap, \symbst) \in \symbelem \wedge \imap \in
      \imapgamma(\absimap)} \wedge \symbst \symbtrans \symbst' \})\\
      & \multicolumn{1}{r}{(\because \; \text{Assumption})}\\
      =& \{ \instant{\symbst'}{\imap} \mid (\absimap, \symbst)
      \in \symbelem \wedge \imap \in \imapgamma(\absimap) \wedge \symbst
      \symbtrans \symbst'\}\\
      & \multicolumn{1}{r}{(\because \; \text{Validity of} \; \symbtrans)}\\
      =& \bigcup \{ \instant{\symbst'}{\absimap} \mid (\absimap, \symbst)
      \in \symbelem \wedge \symbst \symbtrans \symbst' \}\\
      =& \symbgamma(\{ (\absimap, \symbst') \mid (\absimap, \symbst)
      \in \symbelem \wedge \symbst \symbtrans \symbst' \})\\
      =& \symbgamma \circ \symbstep(\symbelem)\\
    \end{array}
  \]
\end{proof}

\begin{lemma}\label{lemma:triage}
  For a given combined state $\combelem \in \combdom$, the $\triage$ function
  satisfies the following two properties:
  \begin{itemize}
    \item $\combgamma(\combelem) \subseteq \combgamma \circ \triage(\combelem)$
    \item $\forall (\absimap, \symbst) \in \symbelem. \; \exists \symbst' \in
      \symbstset.  \; \text{s.t.} \; \symbst \symbtrans \symbst'$
  \end{itemize}
  where $(\sabselem, \symbelem) = \triage(\combelem)$
\end{lemma}
\begin{proof}
  \[
    \fbox{$\combgamma(\combelem) \subseteq \combgamma \circ \triage(\combelem)$}
  \]
  \[
    \begin{array}{cl}
      \multicolumn{2}{l}{\combgamma((\sabselem, \symbelem))}\\
      =& \sgamma(\sabselem) \cup \symbgamma(\symbelem)\\

      =& \left( \underset{\view \in \viewset}{\bigcup} {\viewmap(\view) \cap
      \gamma \circ \sabselem(\view)} \right) \cup \left( \underset{(\absimap,
      \symbst) \in \symbelem}{\bigcup} \instant{\symbst}{\absimap} \right) \\

      =& \left( \underset{\view \in \viewset}{\bigcup} \aelemgamma((\view,
      \sabselem(\view))) \right) \cup \left( \underset{(\absimap, \symbst) \in
      \symbelem}{\bigcup} \aelemgamma((\absimap, \symbst)) \right) \\

      =& \dot\aelemgamma(\{ (\view, \sabselem(\view)) \mid \view \in \viewset \}
      \cup \symbelem)\\

      =& \dot\aelemgamma(\dot{\atriage}(\{ (\view, \sabselem(\view)) \mid \view
      \in \viewset \} \cup \symbelem))\\

       & \multicolumn{1}{r}{(\text{Trivially,} \; \forall \aelem \in \aelemset.
       \; \aelemgamma(\aelem) = \aelemgamma \circ \atriage(\aelem))}\\

      =& \dot\aelemgamma(E)\\
       & \multicolumn{1}{r}{(\text{See the definition of $E$ in
       Definition~\ref{def:triage}})}\\

      =& \left( \underset{(\view, \abselem) \in E}{\bigcup} \aelemgamma((\view,
      \abselem)) \right) \cup \left( \underset{(\absimap, \symbst) \in
    E}{\bigcup} \aelemgamma((\absimap, \symbst)) \right)\\

      =& \left( \underset{(\view, \abselem) \in E}{\bigcup} \viewmap(\view) \cap
      \gamma(\abselem) \right) \cup \left( \underset{(\absimap, \symbst) \in
      E}{\bigcup} \instant{\symbst}{\absimap} \right)\\

      =& \left( \underset{\view \in \viewset}{\bigcup} { \underset{(\view,
      \abselem) \in E}{\bigcup} \viewmap(\view) \cap \gamma(\abselem) } \right)
      \cup \left( \underset{(\absimap, \symbst) \in E}{\bigcup}
      \instant{\symbst}{\absimap} \right)\\

      =& \left( \underset{\view \in \viewset}{\bigcup} {\viewmap(\view) \cap
        \left(\underset{(\view, \abselem) \in
      E}{\bigcup}{\gamma(\abselem)}\right)} \right) \cup \left(
      \underset{(\absimap, \symbst) \in E}{\bigcup} \instant{\symbst}{\absimap}
      \right)\\

      \subseteq& \left( \underset{\view \in \viewset}{\bigcup} {\viewmap(\view)
        \cap \gamma\left( \underset{(\view, \abselem) \in E}{\bigjoin}\abselem
      \right)} \right) \cup \left( \underset{(\absimap, \symbst) \in E}{\bigcup}
      \instant{\symbst}{\absimap} \right)\\

      =& \sgamma\left( \lambda \view. \underset{(\view, \abselem) \in
      E}{\bigjoin}\abselem \right) \cup \symbgamma(E \cap (\absimapset \times
      \symbstset))\\

      =& \combgamma\left( \lambda \view. \underset{(\view, \abselem) \in
      E}{\bigjoin}\abselem, E \cap (\absimapset \times \symbstset) \right)\\

      =& \combgamma \circ \triage((\sabselem, \symbelem))\\
    \end{array}
  \]
  \[\]
  \[
    \fbox{$\forall (\absimap, \symbst) \in \symbelem. \; \exists \symbst' \in
    \symbstset.  \; \text{s.t.} \; \symbst \symbtrans \symbst'$}
  \]

  For a given $(\absimap, \symbst) \in \symbelem$, there exists an analysis
  element $\aelem \in \aelemset$ such that $\atriage(\aelem) = (\absimap,
  \symbst)$.  According to the definition of $\atriage$ in
  Definition~\ref{def:atriage}, there are two possible cases: $\aelem =
  (\absimap, \symbst) \wedge \exists \symbst' \in \symbstset. \; \text{s.t} \;
  \symbst \symbtrans \symbst'$ or $\aelem = (\view, \abselem) \wedge \aelem \in
  \Dom(\asconverter)$. We separately consider those two cases:
  \begin{itemize}
    \item $\aelem = (\absimap, \symbst) \wedge \exists \symbst' \in \symbstset.
      \; \text{s.t} \; \symbst \symbtrans \symbst'$\\
        By definition, $\exists \symbst' \in \symbstset.  \; \text{s.t} \;
        \symbst \symbtrans \symbst'$
    \item $\aelem = (\view, \abselem) \wedge \aelem \in \Dom(\asconverter)$\\
      By the condition~\ref{equ:cond} in the Theorem~\ref{theorem:shortcut},\\
      $\exists k > 1. \symbst \symbtrans^k \excst$.  Thus, $\exists \symbst' \in
      \symbstset.  \; \text{s.t} \; \symbst \symbtrans \symbst'$
  \end{itemize}
\end{proof}


\begin{lemma}\label{lemma:comb-sound2}
  \[
    \forall \combelem \in \combdom. \; \step \circ \combgamma(\combelem) \subseteq
    \combgamma \circ \combstep(\combelem)\\
  \]
\end{lemma}
\begin{proof}
  \[
    \begin{array}{cl}
      \multicolumn{2}{l}{
        \step \circ \combgamma(\combelem)
      }\\
      \subseteq& \step \circ \combgamma((\sabselem, \symbelem))\\
       & \multicolumn{1}{r}{(\because \; \text{First property in
       Lemma~\ref{lemma:triage}}}\\
       & \multicolumn{1}{r}{\text{where} \; (\sabselem, \symbelem)
       = \triage(\combelem).)}\\

      =& \step(\sgamma(\sabselem) \cup \symbgamma(\symbelem))\\
      =& \step(\sgamma(\sabselem)) \cup \step(\symbgamma(\symbelem))\\
      \subseteq& \sgamma \circ \sabsstep(\sabselem) \cup \step(\symbgamma(\symbelem))\\
      & \multicolumn{1}{r}{(\because \; \sabsdom \; \text{is sound.})}\\
      \subseteq& \sgamma \circ \sabsstep(\sabselem) \cup \symbgamma \circ
      \symbstep((\symbelem))\\
               & \multicolumn{1}{r}{(\because \; \text{Sceond property in
               Lemma~\ref{lemma:triage}} }\\
               & \multicolumn{1}{r}{\text{and Lemma~\ref{lemma:step-symb}})}\\
      =& \combgamma((\sabsstep(\sabselem), \symbstep(\symbelem)))\\
      =& \combgamma \circ \combstep(\combelem)\\

      % =& (\sgamma(\sabselem)\cup \sgamma(\sabselem'))
      % \cup (\symbgamma(\symbelem) \cup \symbgamma(\symbelem'))\\
      % \subseteq& \sgamma(\sabselem \join \sabselem')
      % \cup (\symbgamma(\symbelem) \cup \symbgamma(\symbelem'))\\
      % & \multicolumn{1}{r}{(\because \; \sabsdom \; \text{is sound.})}\\
      % =& \sgamma(\sabselem \join \sabselem')
      % \cup \symbgamma(\symbelem \cup \symbelem')\\
      % =& \combgamma((\sabselem \join \sabselem', \symbelem \cup \symbelem'))\\
      % =& \combgamma((\sabselem, \symbelem) \join (\sabselem', \symbelem'))\\
    \end{array}
  \]
\end{proof}

\subsection{Termination}

First, let's define some notations.

\begin{itemize}
\item
Let's define initial state of combined domain as follows:
\[
  \icombelem = (\isabselem, \emptyset)
\]
\item
Let's define $\combelem^i$, $\sabselem^i$, and $\symbelem^i$ for $i \geq 0$ as follows:
\[
  \combelem^i = (\sabselem^i, \symbelem^i) = \combtransfer^i(\icombelem)
\]
which means resulting state after applying transfer function $\combtransfer \; i$ times.
\item
\end{itemize}

\begin{theorem}[Termination]\label{theorem:termination}
  \[
    \exists n \in \numset. \; \combelem^n = \combelem^{n+1}
  \]
\end{theorem}

\begin{proof}
We first begin by showing that sensitive abstract interpretation terminates in
finite time.

\begin{lemma}[Termination of sensitive abstract interpretation]
\label{theorem:sabs-termination}
  \[
    \exists n. \; \forall m \geq n. \;
    \sabselem^m = \sabselem^n
  \]
\end{lemma}

\begin{proof}
Let $\sabselem, \sabselem' \in \sabsdom$ that satisfies
$\combtransfer((\sabselem, \_)) = (\sabselem', \_)$.

Then,
\[
  \begin{array}{rcl}
  \combtransfer((\sabselem, \_))
  &=& (\sabselem, \_) \join \combstep((\sabselem, \_))\\
  &=& (\sabselem, \_) \join (\_, \_) = (\sabselem \join \_, \_)\\
  &=& (\sabselem', \_)
  \end{array}
\]

Therefore, $\sabselem \order \sabselem'$.

Now, since $\combtransfer((\sabselem^i, \_)) = (\sabselem^{i+1}, \_),
\sabselem^i \order \sabselem^{i+1}$ holds for all $i$.
Then, $\sabselem^0 \order \sabselem^1 \order \sabselem^2 ...$ is an ascending chain.
By ascending chain condition, there exists n such that
for all $m \geq n, \sabselem^m = \sabselem^n$.
\end{proof}

Now, let's show that sealed static symbolic execution terminates after
sensitive abstract interpretation terminates.

We begin by defining the difference set $\diffset_i \in \symbdom$ as follows:
\[
  \diffset_i = \symbelem^{i+1} \setminus \symbelem^i
\]

and prove its properties:
\begin{lemma}[Property of difference set]
  \[
    \begin{array}{c}
      \forall i > 0. \; \forall (\absimap, \symbst) \in \diffset_i. \;
      (\exists (\absimap, \symbst') \in \diffset_{i-1} \wedge \symbst' \symbtrans \symbst)\\
      \lor (\exists (\view, \abselem). \; \sabselem^i(\view) = \abselem
        \wedge \asconverter((\view, \abselem)) = (\absimap, \symbst') \wedge \symbst' \symbtrans \symbst))
    \end{array}
  \]
\end{lemma}
\begin{proof}
  Let $i$ and $(\absimap, \symbst) \in \diffset_i = \symbelem^{i+1} \setminus \symbelem^i$ given.
  Note that by definition,
  \[
    \symbelem^{i+1} = \symbelem^i \cup \symbstep(\symbelem')
  \]
  where
  \[
    (\_, \symbelem') = \triage(\sabselem^i, \symbelem^i)
  \]
  which means
  \[
    \symbelem' =
    \dot{\atriage}(\{ (\view, \sabselem^i(\view)) \mid \view \in \viewset \} \cup \symbelem^i)
    \cap (\absimapset \times \symbstset)
  \]
  Now, note that $(\absimap, \symbst) \in \symbstep(\symbelem')$, which means
  \[
    \exists (\absimap, \symbst') \in \symbelem'. \; \symbst' \symbtrans \symbst
  \]
  This means there exists $\aelem \in \{ (\view, \sabselem^i(\view)) \mid \view \in \viewset \} \cup \symbelem^i$
  such that satisfies $\atriage(\aelem) = (\absimap, \symbst')$. We have two possible cases.
  \begin{itemize}
  
  \item $\aelem \in \{ (\view, \sabselem^i(\view)) \mid \view \in \viewset \}$

  In this case, $\atriage(\aelem) = \asconverter(\aelem) = (\absimap, \symbst')$
  and the right condition for conclusion is satisfied.
  
  \item $\aelem \in \symbelem^i$

  In this case, $\atriage(\aelem) = \aelem = (\absimap, \symbst')$.
  Now, let's assume that $\aelem \in \symbelem^{i-1}$.
  In that case, \todo, $(\absimap, \symbst) \in \symbelem^i$
  whcih contradicts to the fact that $(\absimap, \symbst) \in \diffset_i$.
  Therefore, $\aelem \notin \symbelem^{i-1}$, that is,
  $\aelem \in \symbelem^i \setminus \symbelem^{i-1} = \diffset_i$,
  and the left condition for conclusion is satisfied.
  \end{itemize}
\end{proof}

\begin{corollary}
  \[
    \begin{array}{c}
      \forall i > 0. \; \sabselem^{i-1} = \sabselem^{i} \Rightarrow
      \forall (\absimap, \symbst) \in \diffset_i. \;
      (\exists (\absimap, \symbst) \in \diffset_{i-1} \wedge \symbst' \symbtrans \symbst)\\
    \end{array}
  \]
\end{corollary}
\begin{proof}
  \todo
\end{proof}


Now, we can define the TTL(time to live) function
$\ttl_i: \diffset_i \rightarrow \numset$ for $i > 0$ as follows:
\begin{definition}[TTL Function]
  \[
    \begin{array}{l}
      \ttl_i((\absimap, \symbst)) = \\
      \min(\{N\} \cup
      \{\ttl_{i-1}((\absimap, \symbst')) \mid (\absimap, \symbst') \in \diffset_{i-1}
      \wedge \symbst' \symbtrans \symbst\}) - 1
    \end{array}
  \]
\end{definition}

We prove following properties of TTL function.
\begin{lemma}
  \[
    \forall i > 0. \; \forall x \in \diffset_i. \;
    0 <= \ttl_i(x) < N
  \]
\end{lemma}
\begin{proof}
  \todo
\end{proof}

Now, we can prove the Theorem~\ref{theorem:termination}.
\todo

\end{proof}
