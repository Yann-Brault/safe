\section{Formalization}

In this section, we formally define the dynamic shortcut over the abstract
interpretation.


\subsection{Concrete Semantics}

% \[
%   \prog ::= (\lab: \inst)^*\\
% \]
% A program $\prog$ is a sequence of labelled instructions.  We represent the
% semantics of a program $\prog$ as a state transition system $(\stset, \trans,
% \istset)$.  A state $\st \in \stset = \labset \times \memset$ is a pair of a
% label and a memory and represents a status of the program $\prog$.  A memory
% $\mem \in \memset = \locset \finmap \valset$ is a finite mapping from locations
% to values. A program starts with an initial state in $\istset$.  The transition
% relation $\trans \subseteq \stset \times \stset$ describes how states are
% transformed to other states.  It is defined with the \textit{concrete semantics}
% $\sem{\inst}: \stset \rightarrow \powerset{\stset}$ of instructions as follows:
% \[
%   \st \trans \st' \iff \st = (\lab, \_) \wedge \st' \in \sem{\prog(\lab)}(\st)
% \]

We define a program $\prog$ as a state transition system $(\stset, \trans,
\istset)$.  A program starts with an initial state in $\istset$ and the
transition relation $\trans \subseteq \stset \times \stset$ describes how states
are transformed to other states.  A \textit{collecting semantics} $\sem{\prog} =
\{ \st \in \stset \mid \ist \in \istset \wedge \ist \trans^* \st \}$ consists of
reachable states from initial states of the program $\prog$.  We could calculate
it using the \textit{transfer function} $\transfer: \dom \rightarrow \dom$ as
follows:
\[
  \sem{\prog} = \underset{n \rightarrow \infty}{\lim}{\transfer^n(\ielem)}\\
  \qquad
  \transfer(\elem) = \elem \join \step(\elem)\\
\]
The \textit{concrete domain} $\dom = \powerset{\stset}$ is a complete lattice
with $\cup$, $\cap$, and $\subseteq$ as its join($\join$), meet($\meet$), and
partial order($\order$) operators.  The element $\ielem$ denotes the initial
states $\istset$.  The \textit{one-step execution} $\step: \dom \rightarrow
\dom$ transforms states using the transition relation $\trans$: $\step(\elem) =
\{ \st' \mid \st \in \elem \wedge \st \trans \st' \}$.


\subsection{Abstract Interpretation}
The abstract interpretation~\cite{abs-interp-1977, abs-interp-1992}
over-approximate the transfer $\transfer$ to the \textit{abstract transfer
function} $\abstransfer: \absdom \rightarrow \absdom$ to get the
\textit{abstract semantics} $\abssem{\prog}$ in finite iterations as follows:
\[
    \abssem{\prog} = \underset{n \rightarrow
    \infty}{\lim}{(\abstransfer)^n(\iabselem)}\\
\]
We define a \textit{state abstraction} $\dom \galois{\alpha}{\gamma} \absdom$ as
a Galois connection between the concrete domain $\dom$ and an abstract domain
$\absdom$ with a \textit{concretization function} $\gamma$ and a
\textit{abstraction function} $\alpha$.  The initial abstract state $\iabselem
\in \absdom$ represents an abstraction of the initial state set; $\ielem
\subseteq \gamma(\iabselem)$.  The abstract transfer function $\abstransfer:
\absdom \rightarrow \absdom$ is defined as $\abstransfer(\abselem) = \abselem
\join \absstep(\abselem)$ with an \textit{abstract one-step execution}
$\absstep: \absdom \rightarrow \absdom$.  For the sound state abstraction, the
join operator and the abstract one-step execution should satisfy the following
conditions:
\begin{itemize}
  \item $\forall \abselem_0, \abselem_1 \in \absdom. \; \gamma(\abselem_0) \cup
    \gamma(\abselem_1) \subseteq \gamma(\abselem_0 \join \abselem_1)$
  \item $\forall \abselem \in \absdom. \; \absstep \circ \gamma(\abselem) \subseteq
    \gamma \circ \absstep(\abselem)$
\end{itemize}


\subsection{Analysis Sensitivity}

Abstract interpretation is often defined with \textit{analysis sensitivity} to
increase the precision of static analysis.  A sensitive abstract domain
$\sabsdom: \viewset \rightarrow \absdom$ is defined with a \textit{view
abstraction} $\viewmap: \viewset \rightarrow \dom$ that provides multiple points
of views for reachable states during static analysis.  It maps a finite number
of views $\viewset$ to sets of states $\dom$. Each view $\view \in \viewset$
represents a set of states $\viewmap(\view)$.
A \textit{sensitive state abstraction} $\dom
\galois{\alpha_\viewmap}{\gamma_\viewmap} \sabsdom$ is a Galois connection between
the concrete domain $\dom$ and the sensitive abstract domain $\sabsdom$ with the
following concretization function:
\[
  \gamma_\viewmap(\sabselem) = \{ \st \in \stset \mid \forall \view \in \viewset.
  \; \st \in \viewmap(\view) \Rightarrow \st \in \gamma \circ \sabselem(\view) \}
\]

With analysis sensitivities, the abstract one-step execution $\sabsstep:
\sabsdom \rightarrow \sabsdom$ is defined as follows:
\[
  \sabsstep(\sabselem) = \lambda \view \in \viewset. \; \underset{\view' \in
  \viewset}{\bigjoin}{\viewtrans{\view'}{\view} \circ \sabselem(\view')}
\]
where $\viewtrans{\view'}{\view}: \absdom \rightarrow \absdom$ is the abstract
semantics of a \textit{view transition} from a view $\view'$ to another view
$\view$.  It should satsify the following condition for the soundness of the
analysis:
\[
  \forall \abselem \in \absdom. \; \step(\gamma(\abselem) \cap \viewmap(\view'))
  \cap \viewmap(\view) \subseteq \gamma \circ
  \viewtrans{\view'}{\view}(\abselem)
\]

% One of the most widely-used sensitivity techniques is \textit{flow sensitivity}
% using a flow sensitive view abstraction $\fsviewmap: \labset \rightarrow \dom$.
% It discriminates states using their labels as follows:
% \[
%   \forall \lab \in \labset. \; \fsviewmap(\lab) = \{ \st \in \stset \mid \st =
%   (\lab, \_) \}
% \]


\subsection{Lazy Concrete Interpretation}

We define a \textit{lazy concrete interpretation} by extending the transition
relation $\trans$ as a symbolic transition relation $\symbtrans$ on symbolic
states. First, we extends the concrete states $\stset$ to \textit{symbolic
states} with symbolic values $\symbset$ that denote abstract values cannot be
concretized to singleton values. A symbolic transition relation $\symbtrans
\subseteq \symbstset \times (\symbstset \uplus \{ \excst \})$ is exactly same
with the original transition relation $\trans$ except when the relation requires
the exact value of symbolic values.  In this case, the symbolic state has the
relation a special exception state $\excst$ to represent that it is impossible
to interpret in a concrete way.  Thus, a symbolic state \textit{always} has a
symbolic transition relation with a single symbolic state, and the lazy concrete
interpret is linear execution until reaching the exception state.

To freely convert a pair of view and an abstract state to the corresponding
symbolic state and vice versa, we define two domain converters $\symbstset
\galois{\saconverter}{\asconverter} (\viewset \times \absdom)$.  In the
converter $\asconverter$ from abstract states to symbolic states, if an abstract
value $\absval$ represents a singleton value, the function transforms the
abstract value to the corresponding concrete value.  Otherwise, it converts the
abstract value as a symbolic value in the result symbolic state.  Two converters
convert given elements wihtout loss of information:
\[
  \saconverter \circ \asconverter = \asconverter \circ \saconverter = \identity
\]
where $\identity$ denotes the identity function.


\subsection{Combined Analysis}

We define the \textit{combined analysis} of the abstract interpretation and the
lazy concrete interpretation.  In the combined analysis, we use the powerset of
symbolic states as the domain $\combdom = \powerset{\symbstset}$, and extend the
view transition as follows:
\[
  \begin{array}{l}
    \combviewtrans{\view}{\view'}(\combelem) =\\
    \qquad \{
      \symbst' \mid \symbst \in S \wedge
      \symbst \symbtrans \symbst' \wedge
      \saconverter(\symbst') = (\view', \_)
    \}\\
    \qquad \cup \left\{
    \begin{array}{ll}
      \{ \asconverter \circ \viewtrans{\view}{\view'}(\bigjoin D) \}
      & \text{if} \; D \neq \varnothing\\
      \varnothing & \text{otherwise}\\
    \end{array}
    \right.
  \end{array}
\]
where $S = \combelem\mid_{\checker}$ and $D =
\dot{\saconverter}(\combelem\mid_{\neg\checker})$.  The dot notation $\dot{f}$
denotes the element-wise extended function of a function $f$.  We could
configure when the lazy concrete interpretation or the abstract interpretation
is performed based on the definition of the $\checker$ function and its negation
$\neg\checker$.  It should satisfy the following condition for the soundness and
the termination of the combined analysis:
\[
  \checker(\symbst) \Rightarrow \symbst \symbtrans^k \excst \wedge
  1 \leq k \leq N
\]
where $N$ is the pre-defined maximum length of the lazy concrete interpretation.
The combined analysis just performs one-step symbolic transition for each
symbolic state that passes the filter $\checker$. On the other hand, it converts
remaining symbolic states to the corresponding abstract states, merges them into
a single abstract state, and performs the abstract one-step execution for the
abstract state.

% The abstract sensitivity should be defined with a view
% abstraction $\viewmap: \viewset \rightarrow \dom$ more find-grained than the
% flow sensitive view abstraction $\fsviewmap$:
% \[
%   \forall \view \in \viewset. \; \exists \lab \in \labset. \;
%   \viewmap(\view) \subseteq \fsviewmap(\lab)
% \]
