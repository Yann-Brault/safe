\section{Dynamic Shortcut for JavaScript}\label{sec:javascript}

In this section, we introduce the core language of JavaScript that supports
first-class functions, open objects, and first-class property names, and define
sealed symbolic execution of the core language for dynamic shortcut.

\subsection{Core Language of JavaScript}

\begin{figure*}[t]
  \centering

  \fbox{$\st \trans \st$}
  \begin{mathpar}
    \inferrule*[width=0.48\textwidth]
    {
      \prog(\lab) = \refer = \expr\\
      \referrule{\st}{\refer}{\loc}\\
      \exprrule{\st}{\expr}{\val}\\
    }
    {
      \st = (\lab, \mem, \ctxt, \addr)
      \trans
      (\labnext(\lab), \mem[\loc \mapsto \val], \ctxt, \addr)
    }

    \inferrule*[width=0.48\textwidth]
    {
      \prog(\lab) = \refer = \kwobj\\
      \referrule{\st}{\refer}{\loc}\\
      \addr' = \text{(a fresh object address)}
    }
    {
      \st = (\lab, \mem, \ctxt, \addr)
      \trans
      (\labnext(\lab), \mem[\loc \mapsto \addr'], \ctxt, \addr)
    }

    \inferrule*[width=0.48\textwidth]
    {
      \prog(\lab) = \refer = \expr_f ( \expr_a )\\
      \referrule{\st}{\refer}{\loc}\\
      \exprrule{\st}{\expr_f}{\fval{x}{\lab_b}}\\
      \exprrule{\st}{\expr_a}{\val_a}\\
      \addr' = \text{(a fresh environment address)}
    }
    {
      \st = (\lab, \mem, \ctxt, \addr)
      \trans
      (\lab_b, \mem[(\addr', x) \mapsto \val_a], \ctxt[\addr' \mapsto (\addr,
      \labnext(\lab), \loc)], \addr')
    }

    \inferrule*[width=0.48\textwidth]
    {
      \prog(\lab) = \kwret \; \expr\\
      \exprrule{\st}{\expr}{\val}\\
      \ctxt(\addr) = (\addr', \lab', \loc)
    }
    {
      \st = (\lab, \mem, \ctxt, \addr)
      \trans
      (\lab', \mem[\loc \mapsto \val], \ctxt, \addr')
    }

    \inferrule*[width=0.48\textwidth]
    {
      \prog(\lab) = \kwif \; \expr \; \lab'\\
      \exprrule{\st}{\expr}{\kwtrue}\\
    }
    {
      \st = (\lab, \mem, \ctxt, \addr)
      \trans
      (\lab', \mem, \ctxt, \addr)
    }

    \inferrule*[width=0.48\textwidth]
    {
      \prog(\lab) = \kwif \; \expr \; \lab'\\
      \exprrule{\st}{\expr}{\kwfalse}\\
    }
    {
      \st = (\lab, \mem, \ctxt, \addr)
      \trans
      (\labnext(\lab), \mem, \ctxt, \addr)
    }
  \end{mathpar}

  \fbox{$\referrule{\st}{\refer}{\loc}$}
  \begin{mathpar}
    \inferrule*[width=0.48\textwidth]
    {}
    {
      \referrule{\st = (\lab, \mem, \ctxt, \addr)}{x}{(\addr, x)}\\
    }

    \inferrule*[width=0.48\textwidth]
    {
      \exprrule{\st}{\expr_0}{\addr_0}\\
      \exprrule{\st}{\expr_1}{\val_1}\\
      \val_1 \in \strset\\
    }
    {
      \referrule{\st = (\lab, \mem, \ctxt, \addr)}{\expr_0 [ \expr_1
      ]}{(\addr_0, \val_1)}
    }
  \end{mathpar}

  \fbox{$\exprrule{\st}{\expr}{\val}$}
  \begin{mathpar}
    \inferrule*[width=0.48\textwidth]
    {}
    {
      \exprrule{\st = (\lab, \mem, \ctxt, \addr)}{\pval}{\pval}
    }

    \inferrule*[width=0.48\textwidth]
    {}
    {
      \exprrule{\st = (\lab, \mem, \ctxt,
      \addr)}{\fval{x}{\lab'}}{\fval{x}{\lab'}}
    }

    \inferrule*[width=0.48\textwidth]
    {
      \referrule{\st}{\refer}{\loc}\\
      \loc \in \Dom(\mem)
    }
    {
      \exprrule{\st = (\lab, \mem, \ctxt, \addr)}{\refer}{\mem(\loc)}
    }

    \inferrule*[width=0.48\textwidth]
    {
      \exprrule{\st}{\expr_1}{\val_1}\\
      \cdots\\
      \exprrule{\st}{\expr_n}{\val_n}
    }
    {
      \exprrule{\st = (\lab, \mem, \ctxt, \addr)}
      {\op(\expr_1, \cdots, \expr_n)}{\op(\val_1, \cdots, \val_n)}
    }
  \end{mathpar}

  \caption{The transition relation for the core language of JavaScript}
  \label{fig:core-trans-rel}
\end{figure*}

\[
  \begin{array}{ll@{~}c@{~}l}
    \text{Programs} & \prog &::=& (\lab: \inst)^*\\

    \text{Labels} & \lab &\in& \labset\\

    \text{Instructions} & \inst &::=&
    \refer = \expr \mid
    \refer = \kwobj \mid
    \refer = \expr ( \expr ) \mid
    \kwret \; \expr \mid
    \kwif \; \expr \; \lab\\

    \text{References} & \refer &::=&
    x \mid
    \expr [ \expr ]\\

    \text{Expressions} & \expr &::=&
    \pval \mid
    \lambda x. \; \lab \mid
    \refer \mid
    \op(\expr^*)\\
  \end{array}
\]

A program $\prog$ is a sequence of labeled instructions. An instruction $\inst$
is an expression assignment, an object creation, a function call, a return
instruction, or a branch.  A reference $\refer$ is a variable or a property
access of an object.  An expression $\expr$ is a primitive, a lambda function, a
reference, or an operation between other expressions.

\[
  \begin{array}{lr@{~}c@{~}l@{~}c@{~}l}
    \text{States} & \st &\in& \stset &=& \labset \times \memset \times
    \ctxtset \times \eaddrset\\
    \text{Memories} & \mem &\in& \memset &=& \locset \finmap \valset\\
    \text{Contexts} & \ctxt &\in& \ctxtset &=& \eaddrset \finmap (\eaddrset
    \times \labset \times \locset)\\
    \text{Locations} & \loc &\in& \locset &=& (\eaddrset \times \varset) \uplus
    (\oaddrset \times \strset)\\
    \text{Values} & \val &\in& \valset &=& \pvalset \uplus \oaddrset \uplus
    \fvalset\\
    \text{Primitives} & \pval &\in& \pvalset &=& \strset \uplus \cdots\\
    \text{Addresses} & \addr &\in& \addrset &=& \eaddrset \uplus \oaddrset\\
    \text{Functions} & \fval{x}{\lab} &\in& \fvalset &=& \varset \times
    \labset\\
  \end{array}
\]

States $\stset$ consist of labels $\labset$, memories $\memset$, contexts
$\ctxtset$, and environment addresses $\eaddrset$.  A memory $\mem \in \memset$
is a finite mapping from locations to values.  A context $\ctxt \in \ctxtset$ is
a finite mapping from environment addresses to tuple of environment addresses,
return labels, and left-hand side locations.  A location $\loc \in \locset$ is a
variable or an object property; a variable location consists of an environment
address and its name, and an object property location consists of an object
address and a string value.  A value $\val \in \valset$ is a primitive, an
address, or a function value.  An address $\addr \in \addrset$ is an environment
address or an object address.  A function value $\fval{x}{\lab} \in \fvalset$
consists of a parameter and a body label.  In the core language, the closed
scoping is used for functions for brevity thus only parameters and local
variables are accessible in the function body.

We formulate the concrete semantics of the core language as described in
Figure~\ref{fig:core-trans-rel}.  The transition relation between concrete
states is defined with the semantics of references and expressions using two
different forms \fbox{$\referrule{\st}{\refer}{\loc}$} and
\fbox{$\exprrule{\st}{\expr}{\val}$}, respectively.  The initial states are
$\istset = \{ (\ilab, \varnothing, \epsilon, \tladdr) \}$ where $\ilab$ denotes
the initial label, $\epsilon$ empty map, and $\tladdr$ the top-level
environment address.  The function $\labnext$ returns the next label of a
given label in the current program $\prog$.


\subsection{Abstract Semantics}

\begin{figure*}[t]
  \centering

  \fbox{$\viewtrans{\view}{\view'}: \absdom \rightarrow \absdom$}
  \begin{mathpar}
    \inferrule*[width=0.48\textwidth]
    {
      \abselem = (\absmem, \absctxt, \absaddr, \abscount)\\
      \prog(\lab) = \refer = \expr\\
      \referabssem{\refer}(\abselem) = L\\
      \exprabssem{\expr}(\abselem) = \absval
    }
    {
      \viewtrans{\lab}{\labnext(\lab)}(\abselem) =
      (\absmem[L \mapstos \absval], \absctxt, \absaddr, \abscount)
    }

    \inferrule*[width=0.48\textwidth]
    {
      \abselem = (\absmem, \absctxt, \absaddr, \abscount)\\
      \prog(\lab) = \refer = \kwobj\\
      \referabssem{\refer}(\abselem) = L\\
      \oabsaddr = \lab
    }
    {
      \viewtrans{\lab}{\labnext(\lab)}(\abselem) = (\absmem[L \mapstos \{
      \oabsaddr \}], \absctxt, \absaddr, \inc(\abscount, \oabsaddr))
    }

    \inferrule*[width=0.48\textwidth]
    {
      \abselem = (\absmem, \absctxt, \absaddr, \abscount)\\
      \prog(\lab) = \refer = \expr_f ( \expr_a )\\
      \referabssem{\refer}(\abselem) = L\\
      \fval{x}{\lab_b} \in \exprabssem{\expr_f}(\abselem)\\
      \exprabssem{\expr_a}(\abselem) = \absval_a\\
      \eabsaddr = \lab_b\\
      \eabsctxt = \absctxt[\eabsaddr \mapsto \absctxt(\eabsaddr) \cup \{
      (\absaddr, \labnext(\lab), L) \} ]
    }
    {
      \viewtrans{\lab}{\lab_b}(\abselem) = (\absmem[(\eabsaddr, x) \mapsto
      \absval_a], \eabsctxt, \eabsaddr, \inc(\abscount, \eabsaddr))
    }

    \inferrule*[width=0.48\textwidth]
    {
      \abselem = (\absmem, \absctxt, \absaddr, \abscount)\\
      \prog(\lab) = \kwret \; \expr\\
      \exprabssem{\expr}(\abselem) = \absval\\
      (\rabsaddr, \lab', L) \in \absctxt(\absaddr)
    }
    {
      \viewtrans{\lab}{\lab'}(\abselem) = (\absmem[L \mapstos \absval],
      \absctxt, \rabsaddr, \abscount)
    }

    \inferrule*[width=0.48\textwidth]
    {
      \prog(\lab) = \kwif \; \expr \; \lab'\\
      \kwtrue \in \exprabssem{\expr}(\abselem)
    }
    {
      \viewtrans{\lab}{\lab'}(\abselem) = \abselem
    }

    \inferrule*[width=0.48\textwidth]
    {
      \prog(\lab) = \kwif \; \expr \; \lab'\\
      \kwfalse \in \exprabssem{\expr}(\abselem)
    }
    {
      \viewtrans{\lab}{\labnext(\lab)}(\abselem) = \abselem
    }
  \end{mathpar}

  \fbox{$\referabssem{\refer}: \absdom \rightarrow \powerset{\abslocset}$}
  \begin{mathpar}
    \inferrule*[width=0.48\textwidth]
    {
      \abselem = (\absmem, \absctxt, \absaddr, \abscount)
    }
    {
      \referabssem{x}(\abselem) = \{ (\absaddr, x) \}
    }

    \inferrule*[width=0.48\textwidth]
    {
      \abselem = (\absmem, \absctxt, \absaddr, \abscount)\\
      A = \exprabssem{\expr_0}(\abselem) \cap \absaddrset\\
      S = \exprabssem{\expr_1}(\abselem) \cap \strset\\
    }
    {
      \referabssem{\expr_0 [ \expr_1 ]}(\abselem) = A \times S
    }
  \end{mathpar}

  \fbox{$\exprabssem{\expr}: \absdom \rightarrow \absvalset$}
  \begin{mathpar}
    \inferrule*[width=0.48\textwidth]
    {}
    {
      \exprabssem{\pval}(\abselem) = \{ \pval \}
    }

    {}
    {
      \exprabssem{\fval{x}{\lab}}(\abselem) = \{ \fval{x}{\lab} \}
    }

    \inferrule*[width=0.48\textwidth]
    {
      \abselem = (\absmem, \absctxt, \absaddr, \abscount)\\
      \absval = \bigjoin \{ \absmem(\absloc) \mid \absloc \in
      \referabssem{\refer}(\abselem) \}
    }
    {
      \exprabssem{\refer}(\abselem) = \absval
    }

    \inferrule*[width=0.48\textwidth]
    {
      \exprabssem{\expr_1}(\abselem) = \absval_1\\
      \cdots\\
      \exprabssem{\expr_n}(\abselem) = \absval_n
    }
    {
      \exprabssem{\op(\expr_1, \cdots, \expr_n)}(\abselem) = \ops(\absval_1,
      \cdots, \absval_n)
    }
  \end{mathpar}

  \caption{The semantics of view transition for the core language of JavaScript}
  \label{fig:core-view-trans}
\end{figure*}

In abstract semantics of the core language, we use the flow sensitivity with a
flow sensitive view abstraction $\fsviewmap: \labset \rightarrow \dom$ that
discriminates states using their labels: $\forall \lab \in \labset. \;
\fsviewmap(\lab) = \{ \st \in \stset \mid \st = (\lab, \_, \_, \_) \}$. Thus, the
sensitive abstract domain is defined as $\sabsdom = \labset \rightarrow
\absdom$.  We define an abstract state $\abselem \in \absdom$ as a tuple of an
abstract memory, an abstract context, an abstract address, and set of singleton
abstract addresses as follows:

\[
  \begin{array}{lr@{~}c@{~}l@{~}c@{~}l}
    \text{Abstract States} & \abselem &\in& \absdom &=& \absmemset \times \absctxtset
    \times \absaddrset \times \abscountset\\
    \text{Abstract Memories} & \absmem &\in& \absmemset &=& \abslocset \finmap
    \absvalset\\
    \text{Abstract Contexts} & \absctxt &\in& \absctxtset &=& \absaddrset \finmap
    \powerset{\absaddrset \times \viewset \times \powerset{\abslocset}}\\
    \text{Abstract Locations} & \absloc &\in& \abslocset &=& (\absaddrset \times
    \varset) \uplus (\absaddrset \times \strset)\\
    \text{Abstract Values} & \absval &\in& \absvalset &=& \powerset{\pvalset
    \uplus \absaddrset \uplus \fvalset}\\
    \text{Abstract Addresses} & \absaddr &\in& \absaddrset &=& \labset\\
    \text{Abstract Counters} & \abscount &\in& \abscountset &=& \absaddrset
    \rightarrow \{ \abszero, \absone, \absmany \}\\
  \end{array}
\]

An abstract memory $\absmem \in \absmemset$ is a finite mapping from abstract
locations $\abslocset$ to abstract values $\absvalset$.  Abstract locations
$\abslocset$ are pairs of abstract addresses with variable names or string
values. Abstract addresses $\absaddrset$ are defined with the
\textit{allocation-site abstraction} that partitions concrete addresses
$\addrset$ based on their allocation sites $\labset$.  Abstract contexts
$\absctxtset$ are finite maps from abstract addresses to powersets of triples of
abstract addresses, views, and powerset of abstract locations.  For abstract
counting~\cite{abstract-gc-counting, revisit-recency} in static analysis, we
define abstract counters $\abscountset$ that maps from abstract addresses to
their abstract counts representing how many times each abstract address has been
allocated; $\abszero$ denotes that it has never been allocated, $\absone$ once,
and $\absmany$ more than or equals to twice.

We define the semantics of view transition for the core language in
Figure~\ref{fig:core-view-trans}.  For abstract memories, we use the notation
$\absmem[L \mapstos \absval]$ to represent the update of multiple abstract
locations in $L$ with the abstract value $\absval$.  It performs the strong
update if the abstract address for an abstract location $(\absaddr, \_) \in L$
is singleton: $\abscount(\absaddr) = \absone$.  Otherwise, it performs the weak
update for the soundness.  Moreover, we define the increment function $\inc:
\abscountset \times \absaddrset \rightarrow \abscountset$ of the abstract counter
defined as follows:
\[
  \inc(\abscount)(\absaddr_0) = \lambda \absaddr \in \absaddrset. \; \left\{
    \begin{array}{ll}
      \absone & \text{if} \; \absaddr = \absaddr_0 \wedge
      \abscount(\absaddr_0) = \abszero\\
      \absmany & \text{if} \; \absaddr = \absaddr_0 \wedge
      \abscount(\absaddr_0) = \absone\\
      \abscount(\absaddr) & \text{otherwise}
    \end{array}
  \right.
\]


\subsection{Sealed Symbolic Execution}

We define the symbolic states with the extended concrete values and the abstract
counters for addresses as follows:
\[
  \begin{array}{r@{~}c@{~}l}
    \symbstset &=& \labset \times \memset \times \ctxtset \times \eaddrset
    \times \abscountset\\
    \ctxtset &=& \eaddrset \finmap ((\eaddrset \times \labset \times \locset)
    \uplus \symbset)\\
    \valset &=& \pvalset \uplus \oaddrset \uplus \fvalset \uplus \symbset\\
    \abscountset &=& \oaddrset \rightarrow \{ \abszero, \absone, \absmany \}\\
  \end{array}
\]
We define the converter $\asconverter: (\viewset \times \absdom) \rightarrow
\symbstset$ from abstract states to corresponding symbolic states as follows:
\[
  \asconverter((\lab, (\absmem, \absctxt, \absaddr, \abscount))) = (\lab,
  \asconverter^\memset(\absmem), \asconverter^\ctxtset(\absctxt),
  \asconverter^\addrset(\absaddr), \abscount)\\
\]
The converter for memories $\asconverter^\memset$ is defined with the converter
for values $\asconverter^\valset$ where:
\[
  \asconverter^\valset(\absval) = \left\{
    \begin{array}{ll}
      \val & \text{if} \; \absval = \{ \val \}\\
      \absval & \text{otherwise}\\
    \end{array}
  \right.
\]
In a similar way, the converter for contexts $\asconverter^\ctxtset$ is defined
as follows:
\[
  \asconverter^\ctxtset(\absctxt)(\absaddr) = \left\{
    \begin{array}{ll}
      (\absaddr, \lab, \loc) & \text{if} \; \absctxt(\absaddr) = \{ (\absaddr,
      \lab, \{ \loc \}) \}\\
      \absctxt(\absaddr) & \text{otherwise}\\
    \end{array}
  \right.
\]
The opposite converter $\saconverter: \symbstset \rightarrow (\viewset \times
\absdom)$ from symbolic states to abstract states is defined as the inverse
function of $\asconverter$: $\saconverter = \asconverter^{-1}$.
The symbolic transition relation $\symbtrans$ is an extension of the original
concrete transition relation $\trans$.  When the exact values of symbolic values
are required, symbolic states have the symbolic transition relation with the
exception state $\excst$.  For example, we add the following rule for $\kwret$
statements:
\begin{mathpar}
  \inferrule
  {
    \prog(\lab) = \kwret \; \expr\\
    \exprrule{\st}{\expr}{\val}\\
    \ctxt(\addr) \in \symbset
  }
  {
    \st = (\lab, \mem, \ctxt, \addr)
    \trans \excst
  }
\end{mathpar}
We extend each rule of concrete semantics to support such behaviors of symbolic
values.
