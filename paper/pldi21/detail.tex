\section{Application: JavaScript}

In this section, we introduce the core language of JavaScript that supports
first-class functions, open objects, and first-class property names, and define
combined analysis of the core language.

\subsection{Core Language of JavaScript}

\begin{figure*}[t]
  \centering

  \fbox{$\st \trans \st$}
  \begin{mathpar}
    \inferrule*[width=0.48\textwidth]
    {
      \prog(\lab) = \refer = \expr\\
      \referrule{\st}{\refer}{\loc}\\
      \exprrule{\st}{\expr}{\val}\\
    }
    {
      \st = (\lab, \mem, \ctxtstack, \addr)
      \trans
      (\labnext(\lab), \mem[\loc \mapsto \val], \ctxtstack, \addr)
    }

    \inferrule*[width=0.48\textwidth]
    {
      \prog(\lab) = \refer = \kwobj\\
      \referrule{\st}{\refer}{\loc}\\
      \addr' = \text{(a fresh object address)}
    }
    {
      \st = (\lab, \mem, \ctxtstack, \addr)
      \trans
      (\labnext(\lab), \mem[\loc \mapsto \addr'], \ctxtstack, \addr)
    }

    \inferrule*[width=0.48\textwidth]
    {
      \prog(\lab) = \refer = \expr_f ( \expr_a )\\
      \referrule{\st}{\refer}{\loc}\\
      \exprrule{\st}{\expr_f}{\fval{x}{\lab_b}}\\
      \exprrule{\st}{\expr_a}{\val_a}\\
      \addr' = \text{(a fresh environment address)}
    }
    {
      \st = (\lab, \mem, \ctxtstack, \addr)
      \trans
      (\lab_b, \mem[(\addr', x) \mapsto \val_a], (\addr, \labnext(\lab), \loc)
      :: \ctxtstack, \addr')
    }

    \inferrule*[width=0.48\textwidth]
    {
      \prog(\lab) = \kwret \; \expr\\
      \exprrule{\st}{\expr}{\val}\\
    }
    {
      \st = (\lab, \mem, (\addr', \lab', \loc) :: \ctxtstack, \addr)
      \trans
      (\lab', \mem[\loc \mapsto \val], \ctxtstack, \addr')
    }

    \inferrule*[width=0.48\textwidth]
    {
      \prog(\lab) = \kwif \; \expr \; \lab'\\
      \exprrule{\st}{\expr}{\kwtrue}\\
    }
    {
      \st = (\lab, \mem, \ctxtstack, \addr)
      \trans
      (\lab', \mem, \ctxtstack, \addr)
    }

    \inferrule*[width=0.48\textwidth]
    {
      \prog(\lab) = \kwif \; \expr \; \lab'\\
      \exprrule{\st}{\expr}{\kwfalse}\\
    }
    {
      \st = (\lab, \mem, \ctxtstack, \addr)
      \trans
      (\labnext(\lab), \mem, \ctxtstack, \addr)
    }
  \end{mathpar}

  \fbox{$\referrule{\st}{\refer}{\loc}$}
  \begin{mathpar}
    \inferrule*[width=0.48\textwidth]
    {}
    {
      \referrule{\st = (\lab, \mem, \ctxtstack, \addr)}{x}{(\addr, x)}\\
    }

    \inferrule*[width=0.48\textwidth]
    {
      \exprrule{\st}{\expr_0}{\addr_0}\\
      \exprrule{\st}{\expr_1}{\val_1}\\
      \val_1 \in \strset\\
    }
    {
      \referrule{\st = (\lab, \mem, \ctxtstack, \addr)}{\expr_0 [ \expr_1
      ]}{(\addr_0, \val_1)}
    }
  \end{mathpar}

  \fbox{$\exprrule{\st}{\expr}{\val}$}
  \begin{mathpar}
    \inferrule*[width=0.48\textwidth]
    {}
    {
      \exprrule{\st = (\lab, \mem, \ctxtstack, \addr)}{\pval}{\pval}
    }

    \inferrule*[width=0.48\textwidth]
    {}
    {
      \exprrule{\st = (\lab, \mem, \ctxtstack,
      \addr)}{\fval{x}{\lab'}}{\fval{x}{\lab'}}
    }

    \inferrule*[width=0.48\textwidth]
    {
      \referrule{\st}{\refer}{\loc}\\
      \loc \in \Dom(\mem)
    }
    {
      \exprrule{\st = (\lab, \mem, \ctxtstack, \addr)}{\refer}{\mem(\loc)}
    }

    \inferrule*[width=0.48\textwidth]
    {
      \exprrule{\st}{\expr_1}{\val_1}\\
      \cdots\\
      \exprrule{\st}{\expr_n}{\val_n}
    }
    {
      \exprrule{\st = (\lab, \mem, \ctxtstack, \addr)}
      {\op(\expr_1, \cdots, \expr_n)}{\op(\val_1, \cdots, \val_n)}
    }
  \end{mathpar}

  \caption{The transition relation for the core language of JavaScript}
  \label{fig:core-trans-rel}
\end{figure*}

\[
  \begin{array}{ll@{~}c@{~}l}
    \text{Programs} & \prog &::=& (\lab: \inst)^*\\

    \text{Labels} & \lab &\in& \labset\\

    \text{Instructions} & \inst &::=&
    \refer = \expr \mid
    \refer = \kwobj \mid
    \refer = \expr ( \expr ) \mid
    \kwret \; \expr \mid
    \kwif \; \expr \; \lab\\

    \text{References} & \refer &::=&
    x \mid
    \expr [ \expr ]\\

    \text{Expressions} & \expr &::=&
    \pval \mid
    \lambda x. \; \lab \mid
    \refer \mid
    \op(\expr^*)\\
  \end{array}
\]

A program $\prog$ is a sequence of labelled instructions. An instruction $\inst$
is an expression assignment, an object creation, a function call, a return
instruction, or a branch.  A reference $\refer$ is a variable or a property
access of an object.  An expression $\expr$ is a primitive, a lambda function, a
reference, or an operation between other expressions.

\[
  \begin{array}{lr@{~}c@{~}l@{~}c@{~}l}
    \text{States} & \st &\in& \stset &=& \labset \times \memset \times
    \ctxtset^* \times \eaddrset\\
    \text{Memories} & \mem &\in& \memset &=& \locset \finmap \valset\\
    \text{Contexts} & \ctxt &\in& \ctxtset &=& \eaddrset \times \labset \times
    \locset\\
    \text{Locations} & \loc &\in& \locset &=& (\eaddrset \times \varset) \uplus
    (\oaddrset \times \strset)\\
    \text{Values} & \val &\in& \valset &=& \pvalset \uplus \oaddrset \uplus
    \fvalset\\
    \text{Primitives} & \pval &\in& \pvalset &=& \strset \uplus \cdots\\
    \text{Addresses} & \addr &\in& \addrset &=& \eaddrset \uplus \oaddrset\\
    \text{Functions} & \fval{x}{\lab} &\in& \fvalset &=& \varset \times
    \labset\\
  \end{array}
\]

States $\stset$ consist of labels $\labset$, memories $\memset$, context stacks
$\ctxtset^*$, and environment addresses $\eaddrset$.  A memory $\mem \in
\memset$ is a finite mapping from locations to values.  Context stacks is
sequences of contexts $\ctxtset$ and a context $\ctxt \in \ctxtset$ is a tuple
of an environment address, a return label, and a left-hand side location.  A
location $\loc \in \locset$ is a variable or an object property; a variable
location consists of an environment address and its name, and an object property
location consists of an object address and a string value.  A value $\val \in
\valset$ is a primitive, an address, or a function value.  An address $\addr \in
\addrset$ is an environment address or an object address.  A function value
$\fval{x}{\lab} \in \fvalset$ consists of a parameter and a body label.  In the
core language, the closed scoping is used for functions for brevity thus only
parameters and local variables are accessible in the function body.

We formulate the concrete semantics of the core language as described in
Figure~\ref{fig:core-trans-rel}.  The transition relation between concrete
states is defined with the semantics of references and expressions using two
different forms \fbox{$\referrule{\st}{\refer}{\loc}$} and
\fbox{$\exprrule{\st}{\expr}{\val}$}, respectively.  The initial states are
$\istset = \{ (\ilab, \varnothing, \epsilon, \tladdr) \}$ where $\ilab$ denotes
the initial label, $\epsilon$ empty list, and $\tladdr$ the top-level
environment address.  The function $\labnext$ returns the next lable of the
given lable in the current program $\prog$.


\subsection{Abstract Semantics}

\begin{figure*}[t]
  \centering

  \fbox{$\viewtrans{\view}{\view'}: \absdom \rightarrow \absdom$}
  \begin{mathpar}
    \inferrule*[width=0.48\textwidth]
    {
      \abselem = (\absmem, \absctxt, \absaddr, \abscount)\\
      \prog(\lab) = \refer = \expr\\
      \referabssem{\refer}(\abselem) = L\\
      \exprabssem{\expr}(\abselem) = \absval
    }
    {
      \viewtrans{\lab}{\labnext(\lab)}(\abselem) =
      (\absmem[L \mapstos \absval], \absctxt, \absaddr, \abscount)
    }

    \inferrule*[width=0.48\textwidth]
    {
      \abselem = (\absmem, \absctxt, \absaddr, \abscount)\\
      \prog(\lab) = \refer = \kwobj\\
      \referabssem{\refer}(\abselem) = L\\
      \oabsaddr = \lab
    }
    {
      \viewtrans{\lab}{\labnext(\lab)}(\abselem) = (\absmem[L \mapstos \{
      \oabsaddr \}], \absctxt, \absaddr, \inc(\abscount, \oabsaddr))
    }

    \inferrule*[width=0.48\textwidth]
    {
      \abselem = (\absmem, \absctxt, \absaddr, \abscount)\\
      \prog(\lab) = \refer = \expr_f ( \expr_a )\\
      \referabssem{\refer}(\abselem) = L\\
      \fval{x}{\lab_b} \in \exprabssem{\expr_f}(\abselem)\\
      \exprabssem{\expr_a}(\abselem) = \absval_a\\
      \eabsaddr = \lab_b\\
      \eabsctxt = \absctxt[\eabsaddr \mapsto \absctxt(\eabsaddr) \cup \{
      (\absaddr, \lab, L) \} ]
    }
    {
      \viewtrans{\lab}{\lab_b}(\abselem) = (\absmem[(\eabsaddr, x) \mapsto
      \absval_a], \eabsctxt, \eabsaddr, \inc(\abscount, \eabsaddr))
    }

    \inferrule*[width=0.48\textwidth]
    {
      \abselem = (\absmem, \absctxt, \absaddr, \abscount)\\
      \prog(\lab) = \kwret \; \expr\\
      \exprabssem{\expr}(\abselem) = \absval\\
      (\rabsaddr, \lab', L) \in \absctxt(\absaddr)
    }
    {
      \viewtrans{\lab}{\lab'}(\abselem) = (\absmem[L \mapstos \absval],
      \absctxt, \rabsaddr, \abscount)
    }

    \inferrule*[width=0.48\textwidth]
    {
      \prog(\lab) = \kwif \; \expr \; \lab'\\
      \kwtrue \in \exprabssem{\expr}(\abselem)
    }
    {
      \viewtrans{\lab}{\lab'}(\abselem) = \abselem
    }

    \inferrule*[width=0.48\textwidth]
    {
      \prog(\lab) = \kwif \; \expr \; \lab'\\
      \kwfalse \in \exprabssem{\expr}(\abselem)
    }
    {
      \viewtrans{\lab}{\labnext(\lab)}(\abselem) = \abselem
    }
  \end{mathpar}

  \fbox{$\referabssem{\refer}: \absdom \rightarrow \powerset{\abslocset}$}
  \begin{mathpar}
    \inferrule*[width=0.48\textwidth]
    {
      \abselem = (\absmem, \absctxt, \absaddr, \abscount)
    }
    {
      \referabssem{x}(\abselem) = \{ (\absaddr, x) \}
    }

    \inferrule*[width=0.48\textwidth]
    {
      \abselem = (\absmem, \absctxt, \absaddr, \abscount)\\
      A = \exprabssem{\expr_0}(\abselem) \cap \absaddrset\\
      S = \exprabssem{\expr_1}(\abselem) \cap \strset\\
    }
    {
      \referabssem{\expr_0 [ \expr_1 ]} = A \times S
    }
  \end{mathpar}

  \fbox{$\exprabssem{\expr}: \absdom \rightarrow \absvalset$}
  \begin{mathpar}
    \inferrule*[width=0.48\textwidth]
    {}
    {
      \exprabssem{\pval}(\abselem) = \{ \pval \}
    }

    {}
    {
      \exprabssem{\fval{x}{\lab}}(\abselem) = \{ \fval{x}{\lab} \}
    }

    \inferrule*[width=0.48\textwidth]
    {
      \abselem = (\absmem, \absctxt, \absaddr, \abscount)\\
      \absval = \bigjoin \{ \absmem(\absloc) \mid \absloc \in
      \referabssem{\refer}(\abselem) \}
    }
    {
      \exprabssem{\refer}(\abselem) = \absval
    }

    \inferrule*[width=0.48\textwidth]
    {
      \exprabssem{\expr_1}(\abselem) = \absval_1\\
      \cdots\\
      \exprabssem{\expr_n}(\abselem) = \absval_n
    }
    {
      \exprabssem{\op(\expr_1, \cdots, \expr_n)}(\abselem) = \ops(\absval_1,
      \cdots, \absval_n)
    }
  \end{mathpar}

  \caption{The semantics of view transition for the core language of JavaScript}
  \label{fig:core-view-trans}
\end{figure*}

In abstract semantics of the core language, we use the flow sensitivity with a
flow sensitive view abstraction $\fsviewmap: \labset \rightarrow \dom$ that
discriminates states using their labels: $\forall \lab \in \labset. \;
\fsviewmap(\lab) = \{ \st \in \stset \mid \st = (\lab, \_, \_, \_) \}$ Thus, the
sensitive abstract domain is defined as $\sabsdom = \labset \rightarrow
\absdom$.  We define an abstract state $\abselem \in \absdom$ as a tuple of an
abstract memory, an abstract context, an abstract address, and set of singleton
abstract addresses as follows:

\[
  \begin{array}{lr@{~}c@{~}l@{~}c@{~}l}
    \text{Abstract States} & \abselem &\in& \absdom &=& \absmemset \times \absctxtset
    \times \absaddrset \times \abscountset\\
    \text{Abstract Memories} & \absmem &\in& \absmemset &=& \abslocset \finmap
    \absvalset\\
    \text{Abstract Contexts} & \absctxt &\in& \absctxtset &=& \absaddrset \finmap
    \powerset{\absaddrset \times \viewset \times \powerset{\abslocset}}\\
    \text{Abstract Locations} & \absloc &\in& \abslocset &=& (\absaddrset \times
    \varset) \uplus (\absaddrset \times \strset)\\
    \text{Abstract Values} & \absval &\in& \absvalset &=& \powerset{\pvalset
    \uplus \absaddrset \uplus \fvalset}\\
    \text{Abstract Addresses} & \absaddr &\in& \absaddrset &=& \labset\\
    \text{Abstract Counters} & \abscount &\in& \abscountset &=& \absaddrset
    \rightarrow \{ \abszero, \absone, \absmany \}\\
  \end{array}
\]

An abstract memory $\absmem \in \absmemset$ is a finite mapping from abstract
locations $\abslocset$ to abstract values $\absvalset$.  Abstract locations
$\abslocset$ are pairs of abstract addresses with variable names or string
values. Abstract addresses $\absaddrset$ are defined with the
\textit{allocation-site abstraction} that partitions concrete addresses
$\addrset$ based on their allocation sites $\labset$.  Abstract contexts
$\absctxtset$ are finite maps from abstract addresses to powersets of triples of
abstract addresses, views, and powerset of abstract locations.  For abstract
counting~\cite{abstract-gc-counting, revisit-recency} in static analysis, we
define abstract counters $\abscountset$ that maps from abstract addresses to
their abstract counts representing how many times each abstract address has been
allocated; $\abszero$ denotes that it have never been allocated, $\absone$ once,
and $\absmany$ more than or equals to twice.

We define the semantics of view transition for the core language in
Figure~\ref{fig:core-view-trans}.  For abstract memories, we use the notation
$\absmem[L \mapstos \absval]$ to represent the update of multiple abstract
locations in $L$ with the abstract value $\absval$.  It performs the strong
update if the abstract address for an abstract location $(\absaddr, \_) \in L$
is singleton: $\abscount(\absaddr) = \absone$.  Otherwise, it performs the weak
update for the soundness.  Moreover, we define the increment function $\inc:
\abscountset \times \absaddr \rightarrow \abscountset$ of the abstract counter
defined as follows:
\[
  \inc(\abscount)(\absaddr_0) = \lambda \absaddr \in \absaddrset. \; \left\{
    \begin{array}{ll}
      \absone & \text{if} \; \absaddr = \absaddr_0 \wedge
      \abscount(\absaddr_0) = \abszero\\
      \absmany & \text{if} \; \absaddr = \absaddr_0 \wedge
      \abscount(\absaddr_0) = \absone\\
      \abscount(\absaddr) & \text{otherwise}
    \end{array}
  \right.
\]
