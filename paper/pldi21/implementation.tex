\section{Implementation}\label{sec:implementation}
We implemented JavaScript static analysis using dynamic shortcuts
presented in Section~\ref{sec:javascript} in a prototype implementation dubbed
$\tool$.  The tool is an extension of an existing state-of-the-art JavaScript
static analyzer SAFE~\cite{safe, safe2} with a dynamic analyzer
Jalangi~\cite{jalangi}, and it is an open-source project and available online~\footnote{The
URL of the tool is anonymized due to a double-blind review process.}.  In this
section, we introduce challenges and solutions in implementing dynamic
shortcuts on existing JavaScript analyzers.

\paragraph{Sealed Symbolic Values.}
The main challenge of implementing dynamic shortcuts is to support sealed
symbolic execution on an existing JavaScript engine.  To represent an abstract
value, we leverage the \jscode{Proxy} object introduced in ECMAScript 6
(2015, ES6)~\cite{es6}, which allows developers to handle internal behaviors
of specific objects such as property reads and writes and implicit conversions.
We are inspired by \textsc{Mimic}~\cite{mimic}, which used \jscode{Proxy} to
capture accesses from internals of opaque functions.  When the dynamic analyzer
constructs an execution environment at the start of a dynamic shortcut, it
creates \jscode{Proxy} objects to represent abstract values via the
following \jscode{generateSymbol} function:
\begin{lstlisting}[style=myJSstyle]
function generateSymbol() {
  function detect() { /* access detection */ }
  return new Proxy(function() {}, {
    getPrototypeOf: detect,  ...
    construct     : detect
  }); }
var x = generateSymbol();
var y = x;
var z = x + 1;
\end{lstlisting}
The function creates a sealed symbol as a proxy object with a dummy
function object and a handler for all 13 traps using an access detection
function \jscode{detect}.  A sealed symbol invokes the function \jscode{detect}
when any of 13 pre-defined traps are operated on the object, which enables us to
determine whether an object is sealed or not.  For example, the variable
\jscode{y} successfully points to the same symbol stored in \jscode{x}, but the
program invokes the function \jscode{detect} on line 9 because \jscode{x + 1} requires
the actual value of the symbol.  In addition, we instrument unary and binary
operations in Jalangi so that we can detect all the accesses on the
symbol beyond the 13 traps provided by \jscode{Proxy}.
Using this idea, we successfully extended the
JavaScript engine to support sealed symbolic execution.

\paragraph{Synchronization of Control Points.}
For seamless interaction between static analysis and sealed symbolic execution,
synchronization of control points in both worlds is necessary.
The SAFE static analyzer parses a JavaScript program to an Abstract
Syntax Tree (AST), compiles it to its intermediate representation, and
builds a Control Flow Graph (CFG).  It produces annotations for
control points on CFGs including functions, call sites, and object allocation sites.
On the contrary, the Jalangi dynamic analyzer instruments a JavaScript program 
to keep track of necessary information at run time.  Therefore, during
sealed symbolic execution, Jalangi requires the annotations from SAFE to compute
abstract locations of newly created concrete objects and lexical environments.
The key to put annotations on the instrumented code is the source-code
location of the original AST node.  While both CFG of SAFE and
instrumented code of Jalangi maintain the source-code location information,
because they use different parsers we found various location mismatches for corner cases.
Therefore, we synchronize control points of two analyzers by using the closest match
of their source-code locations rather than using their exact match.

\paragraph{Optimizations.}
To use dynamic shortcuts, the static analyzer should communicate with the
dynamic analyzer by passing abstract states and receiving results of sealed
symbolic execution.  When abstract states are massive, sending
abstract states and receiving sealed symbolic values as they are could
incur large performance overhead.  Thus, we
implemented mark-and-sweep garbage collection to remove unreachable
information in abstract states.  In addition, because abstract values
themselves are not used in sealed symbolic execution, we make a map
from unique identifiers to abstract values and replace
abstract values with their unique identifiers when we convert abstract
values to sealed symbolic values.  Therefore, the dynamic analyzer
receives only identifiers of abstract values and wraps them as
\jscode{Proxy} objects.  After finishing sealed symbolic execution,
the static analyzer recovers the abstract values in the results of
sealed symbolic execution by replacing unique identifiers with their
corresponding abstract values.

\paragraph{Termination.}
To guarantee the termination of static analysis using dynamic shortcuts, the
filter $\checker$ should pass a state $\symbst$ only when it terminates in a
bound time $N$.  Since statically checking the termination property is a difficult task,
we simply perform sealed symbolic execution with a pre-determined time limit.  When it runs
over the time limit, we treat it as a failure to pass $\checker$; otherwise, we use
the result of sealed symbolic execution.  Our experiments used 5 seconds 
as the time limit for each sealed symbolic execution.


% \paragraph{Function-Level Dynamic Shortcut.}
% The dynamic shortcut is activated when the current abstract state passes the
% filter $\checker$.  If the filter tolerantly admits the dynamic shortcut, the
% analysis suffers from the frequent communication between static and dynamic
% analyzers.  To diminish the burden of communication, we only activate new
% dynamic shortcut in function entries thus $\tool$ supports only
% \textit{function-level} dynamic shortcut.  Moreover, the filter $\checker$
% should pass only when the given abstract state terminates in a bound time.
% Since it is difficult to staticaly check its termination, we just performs the
% sealed symbolic exeuction with a time limit and we use \inred{5} minutes time
% limit for experiments.  Thus, a sealed symbolic execution introduced by a
% function \jscode{f} terminates when it 1) meets the exit of the function
% \jscode{f}, 2) accesses the inside of sealed symbolic values, or 3) runs over
% the time limit.


% \paragraph{Communication between Analyzers.}
% To perform dynamic shortcut, the static analyzer should communicate with the the
% dynamic analyzer by passing the current abstract state and receiving the final
% result of the sealed symbolic execution.  However, The static analyzer SAFE and
% the dynamic analyzer Jalangi are implemented in different languages Scala and
% JavaScript, respectively.  To overcome the difference, we represent abstract
% states as JSON objects and communicate between analyzers by passing them.  For
% each dynamic shortcut, Jalangi constructs the execution environments based on
% the given JSON object and executes the dynamic analysis from the target program
% points.  After finishing the sealed symbolic execution, it sends a newly
% constructed JSON object to SAFE to update the abstract states in the function
% exit point.


%\paragraph{Abstract Locations for Objects.}
%During dynamic analysis, each JavaScript object should be designated by the
%corresponding abstract location used in the static analysis.  In this paper, we
%define abstract locations using the allocation site
%abstraction~\cite{allocation-site} with heap cloning~\cite{heap-cloning} for
%each abstract context in the static analyzer.  Thus, we instrument the given
%JavaScript program to annotate each object created during dynamic analysis with
%its allocation site and context information.  After the sealed symbolic
%execution, the dynamic analyzer collects the objects based on their annotated
%information for each abstract location.


