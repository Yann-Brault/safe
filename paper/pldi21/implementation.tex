\section{Implementation}\label{sec:implementation}

We have implemented the dynamic shortcut for JavaScript static analysis
presented in Section~\ref{sec:javascript} in a prototype implementation called
$\tool$.  The tool is an extension of an existing state-of-the-art JavaScript
static analyzer SAFE~\cite{safe, safe2} with a dynamic analyzer
Jalangi~\cite{jalangi}, and it is open source and available online~\footnote{The
URL of the tool is anonymized due to a double-blind review process.}.  In this
section, we introduce challenges and solutions when implementing dynamic
shortcut on existing JavaScript analyzers.


\paragraph{Sealed Symbolic Values.}
The main challenge of implementing dynamic shortcut is to support the sealed
symbolic execution on the existing JavaScript engine.  To represent an abstract
value, we leverage the \jscode{Proxy} object introduced in ECMAScript 6
(2015, ES6)~\cite{es6}, which allows developers to handle the internal behaviors
of specific objects (such as property reads and writes, implicit conversions,
etc.).  We are inspired by \textsc{Mimic}~\cite{mimic} using \jscode{Proxy} to
capture accesses from the inside of opaque functions.  When the dynamic analyzer
constructs the execution environments at the start of the dynamic shortcut, it
creates revoked \jscode{Proxy} objects to represent each abstract values via the
following \jscode{generateSymbol} function:
\begin{lstlisting}[style=myJSstyle]
function generateSymbol() {
  const r = Proxy.revocable(function() {}, {});
  r.revoke();
  return r.proxy;
}
var x = generateSymbol();
var y = x;
var z = x + 1;
\end{lstlisting}
The function creates a sealed symbol as a revocable proxy object with a dummy
function object without any handlers and revokes it by
\jscode{revocable.revoke()} to not allow any access of the symbol.  The revoked
object throws a \jscode{TypeError} when the object faces 13 kinds of operations
so we can determine whether or not the seal is open.  For example, the variable
\jscode{y} successfully points to the same symbol stored in \jscode{x} but the
program throws the \jscode{TypeError} in line 8 because \jscode{x + 1} requires
the actual value of the symbol.  Moreover, we instrument unary and binary
operations on Jalangi to fully cover accesses on the symbol beyond 13 traps
provided by \jscode{Proxy}.  Using this idea, we successfully extend the
JavaScript engine to support a sealed symbolic execution.


\paragraph{Synchronization of Control Points.}
For seamless interactions between the static analyzer and dynamic shortcuts,
the synchronization of control points is a prerequisite.
The static analyzer compiles a target JavaScript program to intermediate
representation and builds a control flow graph.  It produces annotations for
control points on the CFG including functions, call sites, and object allocation
sites.  During the sealed symbolic execution, the dynamic analyzer requires
those annotations to calculate sensitive location names of newly created object
and lexical environments.  The key to place annotations on the instrumented code
is the span information of the original AST node.  Both the CFG of SAFE and
instrumented code of Jalangi maintain the span information, but they use
different parsers resulting mismatches for some corner cases.  Thus, we
preprocess to synchronize control points of two analyzers by the closest match
of the span information rather than the exact match.


\paragraph{Optimizations.}
To perform dynamic shortcut, the static analyzer should communicate with the
dynamic analyzer by passing the current abstract state and receiving the final
result of the sealed symbolic execution.  When abstract states are massive, it
is burden to send them as they stand.  Thus, we perform mark-and-sweep garbage
collection to remove unreachable information in the current abstract state.
Moreover, the abstract values are converted to the sealed symbolic values and
their contents are not necessary in the dynamic analysis.  Thus, we replace
abstract values with their unique identifiers and stores the table from
identifiers to abstract values before sending the abstract state
from the static analyzer.  Thus, the dynamic analyzer only receives identifiers
of abstract values and wrap them as \jscode{Proxy} objects.  After finishing the
sealed symbolic execution, the static analyzer recovers the abstract values in
the result abstract state using the table.


\paragraph{Termination.}
To guarantee the termination of static analysis with dynamic shortcut, the
filter $\checker$ should pass the state $\symbst$ only when it terminates in a
bound time $N$.  Since it is difficult to statically check its termination,
we just performs the sealed symbolic execution with a time limit.  When it runs
over the time limit, we treat it fails to pass $\checker$, otherwise we utilizes
the result of the execution.  In the experiments, we set the time limit as
\inred{5 seconds} for each sealed symbolic execution.


% \paragraph{Function-Level Dynamic Shortcut.}
% The dynamic shortcut is activated when the current abstract state passes the
% filter $\checker$.  If the filter tolerantly admits the dynamic shortcut, the
% analysis suffers from the frequent communication between static and dynamic
% analyzers.  To diminish the burden of communication, we only activate new
% dynamic shortcut in function entries thus $\tool$ supports only
% \textit{function-level} dynamic shortcut.  Moreover, the filter $\checker$
% should pass only when the given abstract state terminates in a bound time.
% Since it is difficult to staticaly check its termination, we just performs the
% sealed symbolic exeuction with a time limit and we use \inred{5} minutes time
% limit for experiments.  Thus, a sealed symbolic execution introduced by a
% function \jscode{f} terminates when it 1) meets the exit of the function
% \jscode{f}, 2) accesses the inside of sealed symbolic values, or 3) runs over
% the time limit.


% \paragraph{Communication between Analyzers.}
% To perform dynamic shortcut, the static analyzer should communicate with the the
% dynamic analyzer by passing the current abstract state and receiving the final
% result of the sealed symbolic execution.  However, The static analyzer SAFE and
% the dynamic analyzer Jalangi are implemented in different languages Scala and
% JavaScript, respectively.  To overcome the difference, we represent abstract
% states as JSON objects and communicate between analyzers by passing them.  For
% each dynamic shortcut, Jalangi constructs the execution environments based on
% the given JSON object and executes the dynamic analysis from the target program
% points.  After finishing the sealed symbolic execution, it sends a newly
% constructed JSON object to SAFE to update the abstract states in the function
% exit point.


%\paragraph{Abstract Locations for Objects.}
%During dynamic analysis, each JavaScript object should be designated by the
%corresponding abstract location used in the static analysis.  In this paper, we
%define abstract locations using the allocation site
%abstraction~\cite{allocation-site} with heap cloning~\cite{heap-cloning} for
%each abstract context in the static analyzer.  Thus, we instrument the given
%JavaScript program to annotate each object created during dynamic analysis with
%its allocation site and context information.  After the sealed symbolic
%execution, the dynamic analyzer collects the objects based on their annotated
%information for each abstract location.


