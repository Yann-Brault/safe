/**
 * *****************************************************************************
 * Copyright (c) 2016, KAIST.
 * All rights reserved.
 *
 * Use is subject to license terms.
 *
 * This distribution may include materials developed by third parties.
 * ****************************************************************************
 */

/*
 * A complete JavaScript grammar.
 */
module kr.ac.kaist.safe.parser.JS;
modify kr.ac.kaist.safe.parser.Declaration(Statement, Symbol, Identifier,
                                           Keyword, Spacing)
            as Declaration;
instantiate kr.ac.kaist.safe.parser.Statement(Declaration, Expression,
                                              ExpressionNoIn, Symbol, Identifier,
                                              Keyword, Spacing)
            as Statement;
instantiate kr.ac.kaist.safe.parser.Expression(Declaration, ExpressionNoIn,
                                               Literal, Symbol, Identifier,
                                               Keyword, Spacing)
            as Expression;
instantiate kr.ac.kaist.safe.parser.ExpressionNoIn(Declaration, Expression,
                                                   Literal, Symbol,
                                                   Identifier, Keyword, Spacing)
            as ExpressionNoIn;
instantiate kr.ac.kaist.safe.parser.Literal(Symbol, Identifier, Keyword, Spacing)
            as Literal;
instantiate kr.ac.kaist.safe.parser.Identifier(Symbol, Keyword, Unicode)
            as Identifier;
instantiate kr.ac.kaist.safe.parser.Symbol(Identifier, Keyword, Spacing)
            as Symbol;
instantiate kr.ac.kaist.safe.parser.Spacing(Symbol, Identifier)
            as Spacing;
instantiate kr.ac.kaist.safe.parser.Keyword(Identifier)
            as Keyword;
instantiate kr.ac.kaist.safe.parser.Unicode
            as Unicode;

header {
import java.util.HashMap;
import kr.ac.kaist.safe.nodes.*;
import kr.ac.kaist.safe.safe_util.*;
import edu.rice.cs.plt.tuple.Triple;
import edu.rice.cs.plt.iter.IterUtil;
import edu.rice.cs.plt.collect.CollectUtil;
import xtc.util.Action;
import java.io.*;
import java.util.Collections;
import java.util.ArrayList;
import java.util.LinkedList;
import java.util.List;
import java.lang.reflect.Constructor;
import java.lang.reflect.Field;
import static kr.ac.kaist.safe.errors.SAFEError.error;
import scala.collection.JavaConversions;
import scala.Option;
import scala.Some;
}

body {
    static List<SourceElement> nilJSes = Collections.<SourceElement>emptyList();
    static scala.collection.immutable.List<SourceElement> nilSes = toList(nilJSes);
    static scala.collection.immutable.List<FunDecl> nilFds = toList(Collections.<FunDecl>emptyList());
    static scala.collection.immutable.List<VarDecl> nilVds = toList(Collections.<VarDecl>emptyList());
    static scala.collection.immutable.List<Id> nilIds = toList(Collections.<Id>emptyList());
    static <T> scala.collection.immutable.List<T> toList(List<T> jList) {
        return JavaConversions.asScalaBuffer(jList).toList();
    }

    Span createSpan(int start, int end) {
        int i = end;
        while ( i >= 0 && yyData.length > i && yyData[i] == ' ' ) { i--; }
        if ( i-1 >= start )
            end = i-1;
        else
            end = start;
        Column s = column(start);
        Column e = column(end);
        SourceLoc slStart = new SourceLoc(s.file, s.line, s.column, start);
        SourceLoc slEnd   = new SourceLoc(e.file, e.line, e.column, end);
        return new Span(slStart, slEnd);
    }

    private FileWriter fw;
    private BufferedWriter writer;
    private BufferedReader reader;
    private String logFile = column(0).file + ".log";
    private boolean keepComments = NodeUtil.getKeepComments();
    public Result JSmain(final int yyStart) throws IOException {
        NodeFactory.initComment();
        Result result = this.pJS$File(yyStart);
        if (result.hasValue()) return result;
        else {
            writer.close();
            fw.close();
            return result;
        }
    }

    void initParser() {
        fw = Useful.filenameToFileWriter(logFile);
        writer = new BufferedWriter(fw);
    }

    private void log(String message) {
        NodeUtil.log(writer, message);
    }

    private VarStmt makeArrayNumberLiteral(Span span1, Id name, Span span2) {
        try {
            List<Double> result = new ArrayList<Double>();
            writer.close();
            fw.close();
            FileReader fr = new FileReader(logFile);
            BufferedReader reader = new BufferedReader(fr);
            String line = reader.readLine();
            while (line != null) {
                Double number = NodeFactory.makeNumberLiteral(writer, span2, line);
                result.add(number);
                line = reader.readLine();
            }
            reader.close();
            fr.close();
            Expr expr;
            if (result.size() > 1000)
                expr = new ArrayNumberExpr(NodeFactory.makeASTNodeInfo(span2), toList(result));
            else {
                List<Option<Expr>> elems = new ArrayList<Option<Expr>>();
                for (Double e : result) {
                    elems.add(Some.<Expr>apply((Expr)NodeFactory.makeNumberLiteral(span2, e.toString(), e)));
                }
                expr = new ArrayExpr(NodeFactory.makeASTNodeInfo(span2), toList(elems));
            }

            VarDecl vd = new VarDecl(NodeFactory.makeASTNodeInfo(span1), name, Some.<Expr>apply(expr), false);
            initParser();
            return new VarStmt(NodeFactory.makeASTNodeInfo(span1), toList(list(vd)));
        } catch (IOException error) {
            error("Closing a log file for the parser failed!");
            return new VarStmt(NodeFactory.makeASTNodeInfo(span1), nilVds);
        }
    }
    
    private static <T> List<T> list() {
        return Collections.emptyList();
    }


    public static <T> List<T> list(T x1) {
        ArrayList<T> result = new ArrayList<T>(1);
        result.add(x1);
        return result;
    }

    public static <U, T extends U> List<U> list(List<T> rest, U last) {
        List<U> l = new ArrayList<U>();
        l.addAll(rest);
        l.add(last);
        return l;
    }

    private static <T> List<T> cons(T x, List<T> y) {
        ArrayList<T> result = new ArrayList<T>(1 + y.size());
        result.add(x);
        result.addAll(y);
        return result;
    }
}

option parser(kr.ac.kaist.safe.parser.JS);
