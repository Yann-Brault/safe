\chapter{IR to CFG}

\[
\begin{array}{l@{~~}l}
\LabelMap &: \JSLabel \mapsto \powerset{\CFGBlock}\\
\JSLabel &= \RetLabel \mid \ThrowLabel \mid \ThrowEndLabel \mid \AfterCatchLabel \mid \UserLabel\\
\UserLabel &= \String\\
\transfun{-}_{\emph{root}} &: \IRRoot \rightarrow \CFG \\
\transfun{-}_{\emph{fdvars}} &: \IRFunDecl^{*} \rightarrow \CFGId^{*} \\
\transfun{-}_{\emph{vds}} &: \IRVarStmt^{*} \rightarrow \CFGId^{*} \\
\transfun{-}_{\emph{args}} &: \IRStmt^{*} \rightarrow \CFGId^{*} \\
\transfun{-}_{\emph{functional}} &: \IRFunctional \rightarrow \CFGFunction \\
\transfun{-}_{\emph{fd}} &: \IRFunDecl \times \CFGFunction \times \NormalBlock \rightarrow \Unit \\
\transfun{-}_{\emph{fd}^{*}} &: \IRFunDecl^{*} \times \CFGFunction \times \NormalBlock \rightarrow \Unit \\
\transfun{-}_{\emph{stmt}} &: \IRStmt \times \CFGFunction \times \CFGBlock^{*} \times \LabelMap \rightarrow \CFGBlock^{*} \times \LabelMap\\
\transfun{-}_{\emph{stmt}^{*}} &: \IRStmt^{*} \times \CFGFunction \times \CFGBlock^{*} \times \LabelMap \rightarrow \CFGBlock^{*} \times \LabelMap\\
\transfun{-}_{\emph{mem}} &: \IRField \times \NormalBlock \times \IRId \rightarrow \Unit \\
\transfun{-}_{\emph{elem}} &: \IRExpr \times \NormalBlock \times \IRId \times \Integer \rightarrow \Unit \\
\transfun{-}_{\emph{expr}} &: \IRExpr \rightarrow \CFGExpr \\
\transfun{-}_{\emph{id}} &: \IRId \rightarrow \CFGId \\
\end{array}
\]

We used following global variables for describing the translation from IR to CFG:
\[
\begin{array}{lll}
*\ \emph{catchVars} &: \powerset{\String} & \text{ initializing with } \emptyset\\
*\ \emph{cfg} &: \CFG &\\
*\ \emph{cfgIdMap} &: \String \mapsto \CFGId & \text{ initializing with } [\ ]\\
*\ \emph{currentFunc} &: \CFGFunction & \\
\end{array}
\]
To distinguish global variables, we use the prefix ``(global)'' and ``$\leftarrow$" for assignments.

\[
\begin{array}{l@{}l@{~}l}
\transfun{\IRRoot(\emph{fds}, \emph{vds}, \emph{stmts})}_{\emph{root}}
& = & \emph{globalVars} \letval \transfun{\emph{fds}}_{\emph{fdvars}} ~\emph{++}~ \transfun{\emph{vds}}_{\emph{vds}} \\
& & \text{(global) : } \emph{cfg} \leftarrow \new\ \CFG(\emph{globalVars})\\
& & \emph{globalFunc} \letval \emph{cfg}.\emph{globalFunc}\\
& & \text{(global) : } \emph{currentFunc} \leftarrow \emph{globalFunc}\\
& & \emph{startBlock} \letval \emph{globalFunc}.\emph{breateBlock}\\
& & \emph{cfg}.\emph{addEdge}(\emph{globalFunc}.\emph{entry}, \emph{startBlock})\\
& & \transfun{\emph{fds}}_{\emph{fd}^*}(\emph{globalFunc}, \emph{startBlock})\\
& & (B, L) \letval \transfun{\emph{stmts}}_{\emph{stmt}^{*}}(\emph{globalFunc}, \emph{startBlock}, [\ ])\\
& & \emph{cfg}.\emph{addEdge}(B, \emph{globalFunc}.\emph{exit})\\
& & \emph{cfg}.\emph{addEdge}(L(\TT{ThrowLabel}), \emph{globalFunc}.\emph{exitExc}, \EdgeExc)\\
& & \emph{cfg}.\emph{addEdge}(L(\TT{ThrowEndLabel}), \emph{globalFunc}.\emph{exitExc})\\
& & \emph{cfg}.\emph{addEdge}(L(\TT{AfterCatchLabel}), \emph{globalFunc}.\emph{exitExc})\\
& & \emph{cfg}\\
& & \\

\transfun{\emph{fds}}_{\emph{fdvars}} & = &
\fold(\emph{fds})(\Nil)(\lambda(\emph{vars}, \irfundeclsmall{f}{\_}{\_}{\_}{\_}{\_}{\_} \Rightarrow \emph{vars} :: \transfun{f}_{\emph{id}})\\
& & \\

\transfun{\emph{vds}}_{\emph{vds}} & = &
\fold(\emph{vds})(\Nil)(\lambda(\emph{vars}, \irvar{x})\Rightarrow \emph{vars} :: \transfun{x}_{\emph{id}})\\
& & \\

\transfun{\emph{args}}_{\emph{args}} & = &
\fold(\emph{args})(\Nil)(\lambda(\emph{args}, x = \emph{arguments}[i]) \Rightarrow \emph{args} :: \transfun{x}_{\emph{id}})\\
& & \\

\transfun{\irfunctionalsmall{\_}{\emph{name}}{\emph{params}}{\emph{args}}{\emph{fds}}{\emph{vds}}{\emph{body}}}_{\emph{functional}}
& = & \emph{argVars} \letval \transfun{\emph{args}}_{\emph{args}}\\
& & \emph{localVars} \letval \transfun{\emph{fds}}_{\emph{fdvars}} \emph{++} \transfun{\emph{vds}}_{\emph{vds}}\\
& & \emph{argumentsName} \letval \headOf(\emph{params}).\emph{name}\\
& & \emph{nameStr} \letval \emph{name}.\emph{name}\\
& & \emph{newFunc} \letval \emph{cfg}.\emph{createFunction}(\emph{argumentsName}, \emph{argVars}, \emph{localVars}, \emph{nameStr})\\
& & \emph{oldFunc} \letval \emph{currentFunc}\\
& & \text{(global) : } \emph{currentFunc} \leftarrow \emph{newFunc}\\
& & \emph{startBlock} \letval \emph{newFunc}.\emph{createBlock}\\
& & \emph{cfg}.\emph{addEdge}(\emph{newFunc}.\emph{entry}, \emph{startBlock})\\
& & \transfun{\emph{fds}}_{\emph{fd}^{*}}(\emph{newFunc}, \emph{startBlock})\\
& & (B, L) \letval \transfun{\emph{body}}_{\emph{stmt}^{*}}(\emph{newFunc}, \emph{startBlock}, [\ ])\\
& & \emph{cfg}.\emph{addEdge}(B, \emph{newFunc}.\emph{exit})\\
& & \emph{cfg}.\emph{addEdge}(L(\TT{RetLabel}), \emph{newFunc}.\emph{exit})\\
& & \emph{cfg}.\emph{addEdge}(L(\TT{ThrowLabel}), \emph{newFunc}.\emph{exitExc}, \EdgeExc)\\
& & \emph{cfg}.\emph{addEdge}(L(\TT{ThrowEndLabel}), \emph{newFunc}.\emph{exitExc})\\
& & \emph{cfg}.\emph{addEdge}(L(\TT{AfterCatchLabel}), \emph{newFunc}.\emph{exitExc})\\
& & \text{(global) : } \emph{currentFunc} \leftarrow \emph{oldFunc}\\
& & \emph{newFunc}\\
& & \\

\transfun{\IRFunDecl(\emph{functional})}_{\emph{fd}}(\emph{func}, \emph{block})
& = & \emph{lhs} \letval \transfun{\emph{functional}.\emph{name}}_{\emph{id}}\\
& & \emph{newFunc} \letval \transfun{\emph{functional}}_{\emph{functional}}\\
& & (\emph{addr1}, \emph{addr2}) \letval (\new\ \Address,\ \new\ \Address)\\
& & \emph{block}.\emph{createInst}(\emph{lhs} := \TT{function}\ (\emph{newFunc} ~@~ \emph{addr1},\ \emph{addr2}))\\
& & \\

\transfun{\emph{fds}}_{\emph{fd}^{*}}(\emph{func}, \emph{block})
& = & \iter(\emph{fds})(\lambda(\emph{fd}) \Rightarrow \transfun{fd}_{\emph{fd}}(\emph{func}, \emph{block}))\\
& & \\

\transfun{\irstmtunit{\emph{stmts}}}_{\emph{stmt}}(f, B, L) & = &
\transfun{\emph{stmts}}_{\emph{stmt}^{*}}(f, B, L)\\
& & \\

\transfun{\irseq{\emph{stmts}}}_{\emph{stmt}}(f, B, L) & = &
\transfun{\emph{stmts}}_{\emph{stmt}^{*}}(f, B, L)\\
\end{array}
\]

\[
\begin{array}{l@{}l@{~}l}
\transfun{\SF{IRFunExpr}(\emph{lhs}, \emph{functional})}_{\emph{stmt}}(f, B, L)
& = & \emph{newFunc} \letval \transfun{\emph{functional}}_{\emph{functional}}\\
& & (\emph{addr1}, \emph{addr2}, \emph{addr3}) \letval (\new\ \Address,\ \new\ \Address,\ \new\ \Address)\\
& & \emph{name} \letval \transfun{\emph{functional}.\emph{name}}_{\emph{id}}\\
& & \emph{tailBlock} \letval \getTail(B, f)\\
& & if\ (\emph{name}.\emph{kind} = \TT{CapturedVar}) \\
& & \phantom{if} \emph{tailBlock}.\emph{createInst}(\emph{lhs} := \TT{function}\ \emph{name}\ (\emph{newFunc} ~@~ \emph{addr1},\ \emph{addr2},\ \emph{addr3}))\\
& & else\\
& & \phantom{if} \emph{tailBlock}.\emph{createInst}(\emph{lhs} := \TT{function}\ (\emph{newFunc} ~@~ \emph{addr1},\ \emph{addr2}))\\
& & (\emph{tailBlock}, L)\\
& & \\

\transfun{\irobject{x}{\emph{members}}}_{\emph{stmt}}(f, B, L)
& = & \emph{tailBlock} \letval \getTail(B, f)\\
& & \emph{addr1} \letval \new\ \Address\\
& & \emph{tailBlock}.\emph{createInst}(x := \TT{alloc}() ~@~ \emph{addr1})\\
& & iter(\emph{members})(\lambda(m) \Rightarrow \transfun{m}_{\emph{mem}}(tailBlock, x))\\
& & (\emph{tailBlock}, L[\ThrowLabel \mapsto \emph{tailBlock} \cup L(\ThrowLabel)])\\
& & \\

\transfun{\irobject{x}{\emph{members}, \emph{proto}}}_{\emph{stmt}}(f, B, L)
& = & \emph{tailBlock} \letval \getTail(B, f)\\
& & \emph{protoId} \letval \transfun{\emph{proto}}_{\emph{id}}\\
& & \emph{addr1} \letval \new\ \Address\\
& & \emph{tailBlock}.\emph{createInst}(x := \TT{alloc}(\emph{protoId}) ~@~ \emph{addr1})\\
& & iter(\emph{members})(\lambda(m) \Rightarrow \transfun{m}_{\emph{mem}}(tailBlock, x))\\
& & (\emph{tailBlock}, L[\ThrowLabel \mapsto \emph{tailBlock} \cup L(\ThrowLabel)])\\
& & \\

\transfun{\ircfgtrycat{\emph{body}}{x}{\emph{catIR}}}_{\emph{stmt}}(f, B, L)
& = & \text{(global) : } \emph{catchVars} \leftarrow \emph{catchVars} \cup \{ x.\emph{name} \}\\
& & \emph{tryB} \letval f.\emph{createBlock}\\
& & \emph{cfg}.\emph{addEdge}(B, \emph{tryB})\\
& & \emph{catB} \letval f.\emph{createBlock}\\
& & \emph{catB}.\emph{createInst}(\TT{catch}(transfun{x}_{\emph{id}}))\\
& & (\emph{trybs}, \emph{trylmap}) \letval \transfun{\emph{body}}_{\emph{stmt}}(f, \emph{tryB}, [\ ])\\
& & \emph{cfg}.\emph{addEdge}(\emph{trylmap}(\ThrowLabel), \emph{catB}, \EdgeExc)\\
& & \emph{cfg}.\emph{addEdge}(\emph{trylmap}(\ThrowEndLabel), \emph{catB})\\
& & \emph{cfg}.\emph{addEdge}(\emph{trylmap}(\AfterCatchLabel), \emph{catB})\\
& & \emph{tmplmap} \letval \emph{trylmap} - \ThrowLabel - \ThrowEndLabel - \AfterCatchLabel\\
& & (\emph{catchbs}, \emph{catchlamp}) \letval \transfun{\emph{catIR}}_{\emph{stmt}}(f, \emph{catB}, \emph{tmplmap})\\
& & (\emph{trybs} ~\emph{++}~ \emph{catchbs}, L ~\emph{++}~ \emph{catchlmap})\\
& & \\

\transfun{\ircfgtryfin{\emph{body}}{\emph{finIR}}}_{\emph{stmt}}(f, B, L)
& = & \emph{tryB} \letval f.\emph{createBlock}\\
& & \emph{cfg}.\emph{addEdge}(B, \emph{tryB})\\
& & \emph{finB} \letval f.\emph{createBlock}\\
& & (\emph{trybs}, \emph{trylmap}) \letval \transfun{\emph{body}}_{\emph{stmt}}(f, \emph{tryB}, [\ ])\\
& & (\emph{finbs}, \emph{finlamp}) \letval \transfun{\emph{finIR}}_{\emph{stmt}}(f, \emph{finB}, L)\\
& & \emph{cfg}.\emph{addEdge}(\emph{trybs}, \emph{finB})\\
& & \emph{reslmap} \letval \fold(\emph{trylmap} - \AfterCatchLabel)(\emph{finlmap})
(\lambda((l, B'), L') \Rightarrow \\
& & \quad \emph{dupB} \letval f.\emph{createBlock}\\
& & \quad (B'', L'') \letval \transfun{\emph{finIR}}_{\emph{stmt}}(f, \emph{dupB}, L')\\
& & \quad if\ (l = \ThrowLabel)\\
& & \quad \phantom{if} \emph{cfg}.\emph{addEdge}(\emph{trylmap}(\AfterCatchLabel), \emph{dupB})\\
& & \quad \phantom{if} \emph{cfg}.\emph{addEdge}(B', \emph{dupB}, \EdgeExc)\\
& & \quad \phantom{if} L''[\ThrowEndLabel \mapsto (L''(\ThrowEndLabel) ~\emph{++}~ B'')]\\
& & \quad else\\
& & \quad \phantom{if} \emph{cfg}.\emph{addEdge}(B', \emph{dupB}, \EdgeExc)\\
& & \quad \phantom{if} L''[l \mapsto (L''(l) ~\emph{++}~ B'')]\\
& & )\\
& & (\emph{finbs}, \emph{reslmap})\\
& & \\
\end{array}
\]

\[
\begin{array}{l@{}l@{~}l}
\transfun{\irtryfull{\emph{body}}{x}{\emph{catIR}}{\emph{finIR}}}_{\emph{stmt}}(f, B, L)
& = & \text{(global) : } \emph{catchVars} \leftarrow \emph{catchVars} \cup \{ x.\emph{name} \}\\
& & \emph{tryB} \letval f.\emph{createBlock}\\
& & \emph{cfg}.\emph{addEdge}(B, \emph{tryB})\\
& & \emph{catB} \letval f.\emph{createBlock}\\
& & \emph{catB}.\emph{createInst}(\TT{catch}(transfun{x}_{\emph{id}}))\\
& & \emph{finB} \letval f.\emph{createBlock}\\
& & (\emph{trybs}, \emph{trylmap}) \letval \transfun{\emph{body}}_{\emph{stmt}}(f, \emph{tryB}, [\ ])\\
& & \emph{cfg}.\emph{addEdge}(\emph{trylmap}(\ThrowLabel), \emph{catB}, \EdgeExc)\\
& & \emph{cfg}.\emph{addEdge}(\emph{trylmap}(\ThrowEndLabel), \emph{catB})\\
& & \emph{cfg}.\emph{addEdge}(\emph{trylmap}(\AfterCatchLabel), \emph{catB})\\
& & (\emph{catchbs}, \emph{catchlamp}) \letval \transfun{\emph{catIR}}_{\emph{stmt}}(f, \emph{catB}, \emph{tmplmap})\\
& & (\emph{finbs}, \emph{finlamp}) \letval \transfun{\emph{finIR}}_{\emph{stmt}}(f, \emph{finB}, L)\\
& & \emph{cfg}.\emph{addEdge}(\emph{trybs} ~\emph{++}~ \emph{catchbs}, \emph{finB})\\
& & \emph{reslmap} \letval \fold(\emph{catchlmap} - \AfterCatchLabel)(\emph{finlmap})
(\lambda((l, B'), L') \Rightarrow \\
& & \quad \emph{dupB} \letval f.\emph{createBlock}\\
& & \quad (B'', L'') \letval \transfun{\emph{finIR}}_{\emph{stmt}}(f, \emph{dupB}, L')\\
& & \quad if\ (l = \ThrowLabel)\\
& & \quad \phantom{if} \emph{cfg}.\emph{addEdge}(\emph{catchlmap}(\AfterCatchLabel), \emph{dupB})\\
& & \quad \phantom{if} \emph{cfg}.\emph{addEdge}(B', \emph{dupB}, \EdgeExc)\\
& & \quad \phantom{if} L''[\ThrowEndLabel \mapsto (L''(\ThrowEndLabel) ~\emph{++}~ B'')]\\
& & \quad else\\
& & \quad \phantom{if} \emph{cfg}.\emph{addEdge}(B', \emph{dupB}, \EdgeExc)\\
& & \quad \phantom{if} L''[l \mapsto (L''(l) ~\emph{++}~ B'')]\\
& & )\\
& & (\emph{finbs}, \emph{reslmap})\\
& & \\

\transfun{\irarray{x}{\emph{elems}}}_{\emph{stmt}}(f, B, L)
& = & \emph{tailBlock} \letval \getTail(B, f)\\
(\TT{arguments}) & & \emph{addr} \letval \new\ \Address\\
& & \emph{tailBlock}.\emph{createInst}(x := \TT{allocArg}(\length(\emph{elems})) ~@~ \emph{addr})\\
& & \iter(\emph{elems})(0)(\lambda(e,k) \Rightarrow \transfun{e}_{\emph{elem}}(\emph{tailBlock}, x, k))\\
& & (\emph{tailBlock}, L[\ThrowLabel \mapsto L(\ThrowLabel) \cup \{ \emph{tailBlock} \})\\
& & \\

\transfun{\irarray{x}{\emph{elems}}}_{\emph{stmt}}(f, B, L)
& = & \emph{tailBlock} \letval \getTail(B, f)\\
& & \emph{addr} \letval \new\ \Address\\
& & \emph{tailBlock}.\emph{createInst}(x :=\TT{allocArray}(\length(\emph{elems})) ~@~ \emph{addr})\\
& & \iter(\emph{elems})(0)(\lambda(e,k) \Rightarrow \transfun{e}_{\emph{elem}}(\emph{tailBlock}, x, k))\\
& & (\emph{tailBlock}, L[\ThrowLabel \mapsto L(\ThrowLabel) \cup \{ \emph{tailBlock} \})\\
& & \\

\transfun{\sf{break}\ \emph{label}}_{\emph{stmt}}(f, B, L)
& = & \emph{key} \letval \emph{label}.\emph{name}\\
& & \emph{bs} \letval L(\emph{key}) \cup B\\
& & (\emptyset, L[\emph{key} \mapsto \emph{bs}])\\
& & \\

% TODO IRInternalCall

\transfun{\ircfgcall{x}{\emph{fun}}{\emph{thisB}, \emph{args}}}_{\emph{stmt}}(f, B, L)
& = & \emph{tailBlock} \letval \getTail(B, f)\\
& & \emph{thisId} \letval \new\ \CFGId(\TT{<>this<>}, \TT{PureLocalVar})\\
& & \emph{tailBlock}.\emph{createInst}(\emph{thisId} := \TT{enterCode}(\transfun{\emph{thisB}}_{\emph{id}}))\\
& & (\emph{addr1}, \emph{addr2}) \letval (\new\ \Address,\ \new\ \Address)\\
& & \emph{call} \letval \emph{tailBlock}.\emph{func}.\emph{createCall}(\TT{call}(\transfun{\emph{fun}}_{\emph{id}}, \emph{thisId}, \transfun{\emph{args}}_{\emph{id}}) ~@~ \emph{addr1},\ \emph{addr2}, \transfun{x}_{\emph{id}})\\
& & \emph{cfg}.\emph{addEdge}(\emph{tailBlock}, \emph{call})\\
& & (\emph{call}.\emph{afterCall}, L[\\
& & \quad \ThrowLabel \mapsto L(\ThrowLabel) \cup \{ \emph{call}, \emph{tailBlock} \},\\
& & \quad \AfterCatchLabel \mapsto L(\AfterCatchLabel) \cup \{ \emph{call}.\emph{afterCatch} \}\\
& & ])\\
\end{array}
\]
\[
\begin{array}{l@{}l@{~}l}
\transfun{\ircfgnew{x}{\emph{cons}}{\emph{args}}}_{\emph{stmt}}(f, B, L)
& = & \emph{tailBlock} \letval \getTail(B, f)\\
(irnew) & & (\emph{addr1}, \emph{addr2}) \letval (\new\ \Address,\ \new\ \Address)\\
& & \emph{call} \letval \emph{tailBlock}.\emph{func}.\emph{createCall}(\\
& & \quad \TT{construct}(\transfun{\emph{cons}}_{\emph{id}}, \transfun{\emph{args}(0)}_{\emph{id}}, \transfun{\emph{args}(1)}_{\emph{id}}) ~@~ \emph{addr1},\ \emph{addr2}, \transfun{x}_{\emph{id}}\\
& & )\\
& & (\emph{call}.\emph{afterCall}, L[\\
& & \quad \ThrowLabel \mapsto L(\ThrowLabel) \cup \{ \emph{call}, \emph{tailBlock} \},\\
& & \quad \AfterCatchLabel \mapsto L(\AfterCatchLabel) \cup \{ \emph{call}.\emph{afterCatch} \}\\
& & ])\\
& & \\

\transfun{\irdelete{x}{y}}_{\emph{stmt}}(f, B, L)
& = & \emph{tailBlock} \letval \getTail(B, f)\\
& & \emph{tailBlock}.\emph{createInst}(\transfun{x}_{\emph{id}} := \TT{delete}(\transfun{y}_{\emph{id}}))\\
& & (\emph{tailBlock}, L[\ThrowLabel \mapsto L(\ThrowLabel) \cup \{ \emph{tailBlock} \}])\\
& & \\

\transfun{\irdeleteobj{x}{y}{z}}_{\emph{stmt}}(f, B, L)
& = & \emph{tailBlock} \letval \getTail(B, f)\\
& & \emph{tailBlock}.\emph{createInst}(\transfun{x}_{\emph{id}} := \TT{delete}(\transfun{y}_{\emph{id}}, \transfun{z}_{\emph{expr}}))\\
& & (\emph{tailBlock}, L[\ThrowLabel \mapsto L(\ThrowLabel) \cup \{ \emph{tailBlock} \}])\\
& & \\

\transfun{\ircfgexpr{x}{e}}_{\emph{stmt}}(f, B, L)
& = & \emph{tailBlock} \letval \getTail(B, f)\\
& & \emph{tailBlock}.\emph{createInst}(\transfun{x}_{\emph{id}} := \transfun{e}_{\emph{expr}})\\
& & (\emph{tailBlock}, L[\ThrowLabel \mapsto L(\ThrowLabel) \cup \{ \emph{tailBlock} \}])\\
& & \\

\transfun{\ircfgif{\emph{cond}}{\emph{trueIR}}}_{\emph{stmt}}(f, B, L)
& = & \emph{falseB} \letval f.\emph{createBlock}\\
& & \emph{cfg}.\emph{addEdge}(B, \emph{falseB})\\
& & \emph{cfgCond} \letval \transfun{\emph{cond}}_{\emph{expr}}\\
& & \emph{trueB}.\emph{createInst}(\TT{assert}(\emph{cfgCond}))\\
& & \emph{falseB}.\emph{createInst}(\TT{assert}(\neg \emph{cfgCond}))\\
& & (B', L') \letval \transfun{\emph{trueIR}}_{\emph{stmt}}(f, trueB, L)\\
& & \emph{endB} \letval f.\emph{createBlock}\\
& & \emph{cfg}.\emph{addEdge}(\{ \emph{falseB},\ B' \}, \emph{endBlock})\\
& & (\emph{endB}, L'[\ThrowLabel \mapsto L'(\ThrowLabel) \cup \{ \emph{trueB},\ \emph{falseB} \}])\\
& & \\

\transfun{\irifelse{\emph{cond}}{\emph{trueIR}}{\emph{falseIR}}}_{\emph{stmt}}(f, B, L)
& = & \emph{falseB} \letval f.\emph{createBlock}\\
& & \emph{cfg}.\emph{addEdge}(B, \emph{falseB})\\
& & \emph{cfgCond} \letval \transfun{\emph{cond}}_{\emph{expr}}\\
& & \emph{trueB}.\emph{createInst}(\TT{assert}(\emph{cfgCond}))\\
& & \emph{falseB}.\emph{createInst}(\TT{assert}(\neg \emph{cfgCond}))\\
& & (B', L') \letval \transfun{\emph{trueIR}}_{\emph{stmt}}(f, trueB, L)\\
& & \emph{endB} \letval f.\emph{createBlock}\\
& & (B'', L'') \letval \transfun{\emph{falseIR}}_{\emph{stmt}}(f, falseB, L')\\
& & \emph{cfg}.\emph{addEdge}(B' ~\emph{++}~ B'', \emph{endB})\\
& & (\emph{endB}, L''[\ThrowLabel \mapsto L''(\ThrowLabel) \cup \{ \emph{trueB},\ \emph{falseB} \}])\\
& & \\

\transfun{\irlabel{l}{s}}_{\emph{stmt}}(f, B, L)
& = & b \letval f.\emph{createBlock}\\
& & (B', L') \letval \transfun{s}_{\emph{stmt}}(f, B, L)\\
& & \emph{label} \letval l.\emph{name}\\
& & \emph{cfg}.\emph{addEdge}(B', b)\\
& & \emph{cfg}.\emph{addEdge}(L'(\emph{label}), b)\\
& & (b, L' - l)\\
& & \\

\transfun{\irreturn{}}_{\emph{stmt}}(f, B, L)
& = & \emph{tailBlock} \letval \getTail(B, f)\\
& & \emph{tailBlock}.\emph{createInst}(\TT{return}())\\
& & (\emptyset, L[\RetLabel \mapsto L(\RetLabel) \cup \{ \emph{tailBlock}\}])\\
& & \\

\transfun{\ircfgreturn{x}}_{\emph{stmt}}(f, B, L)
& = & \emph{tailBlock} \letval \getTail(B, f)\\
& & \emph{tailBlock}.\emph{createInst}(\TT{return}(\transfun{x}_{\emph{id}}))\\
& & (\emptyset, L[\RetLabel \mapsto L(\RetLabel) \cup \{ \emph{tailBlock}\}])\\
\end{array}
\]

\[
\begin{array}{l@{}l@{~}l}
\transfun{\irstore{o}{p}{v}}_{\emph{stmt}}(f, B, L)
& = & \emph{tailBlock} \letval \getTail(B, f)\\
& & \emph{tailBlock}.\emph{createInst}(\transfun{o}_{\emph{expr}}[\transfun{p}_{\emph{expr}}] := \transfun{v}_{\emph{expr}})\\
& & (\emph{tailBlock}, L[\ThrowLabel \mapsto L(\ThrowLabel) \cup \{ \emph{tailBlock} \}])\\
& & \\

\transfun{\irthrow{e}}_{\emph{stmt}}(f, B, L)
& = & \emph{tailBlock} \letval \getTail(B, f)\\
& & \emph{tailBlock}.\emph{createInst}(\TT{throw}(\transfun{e}_{\emph{expr}}))\\
& & (\emptyset, L[\ThrowLabel \mapsto L(\ThrowLabel)] \cup \{ \emph{tailBlock} \})\\
& & \\

\transfun{\ircfgwhile{e}{s}}_{\emph{stmt}}(f, B, L)
& = & \emph{tailBlock} \letval \getTail(B, f)\\
& & \emph{head} \letval f.\emph{createBlock}\\
& & \emph{body} \letval f.\emph{createBlock}\\
& & \emph{out} \letval f.\emph{createBlock}\\
& & \emph{body}.createInst(\TT{assert}(e))\\
& & \emph{out}.createInst(\TT{assert}(\neg e))\\
& & \emph{cfg}.\emph{addEdge}(\emph{tailBlock}, \emph{head})\\
& & \emph{cfg}.\emph{addEdge}(\emph{head}, \emph{body})\\
& & \emph{cfg}.\emph{addEdge}(\emph{head}, \emph{out})\\
& & (B', L') \letval \transfun{s}_{\emph{stmt}}(\emph{cfg}, f, [\emph{body}], L)\\
& & \emph{cfg}.\emph{addEdge}(B', \emph{head})\\
& & (\emph{out}, L'[\ThrowLabel \mapsto L'(\ThrowLabel) \cup \{ \emph{body},\ \emph{out} \}) \\
& & \\

\transfun{\emph{stmts}}_{\emph{stmt}^{*}}(f, B, L)
& = & \fold(\emph{stmts})((B, L))(\lambda((B', L'), \emph{stmt}) \Rightarrow \transfun{\emph{stmt}}_{\emph{stmt}}(f, B', L'))\\
& & \\

\transfun{\emph{mem}}_{\emph{mem}}(b, x)
& = & \emph{lhs} \letval \transfun{x}_{\emph{id}}\\
& & \emph{str} \letval \emph{mem}.\emph{prop}.\emph{name}\\
& & \emph{expr} \letval \transfun{\emph{mem}.\emph{expr}}_{emph{expr}}\\
& & b.\emph{createInst}(\emph{lhs}[\emph{str}] := \emph{expr})\\
& & \\

\transfun{y}_{\emph{elem}}(b, x, k)
& = & \emph{lhs} \letval \transfun{x}_{\emph{id}}\\
& & \emph{expr} \letval \transfun{x}_{\emph{expr}}\\
& & b.\emph{createInst}(\emph{lhs} [``k"] := \emph{expr})\\
& & \\

\transfun{x \inop y}_{\emph{expr}} & = & \transfun{x}_{\emph{expr}} \inop \transfun{y}_{\emph{expr}}\\
& & \\

\transfun{\preop x}_{\emph{expr}} & = & \preop \transfun{x}_{\emph{expr}}\\
& & \\

\transfun{o [e]}_{\emph{expr}} & = & \transfun{o}_{\emph{expr}} [ \transfun{e}_{\emph{expr}} ]\\
& & \\

\transfun{\this}_{\emph{expr}} & = & \this\\
& & \\

\transfun{v}_{\emph{expr}} & = & v\\
& & \\

\transfun{x}_{\emph{id}}
& = & \text{let }\emph{kind} \text{ be a } \VarKind \text{ based on the information from } \TT{CapturedVariableCollector}\\
& & \new\ \CFGId(x.\emph{name}, \emph{kind})\\
\end{array}
\]
\newpage
