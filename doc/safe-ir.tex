\chapter{IR}
\small
\[
\begin{array}{llll}
\ir\pgm & ::= & \ir\stmt^* & \mtt{IRRoot(val fds:~List[IRFunDecl], val vds:~List[IRVarStmt],}\\
&&&\mtt{\phantom{IRRoot(}val irs:~List[IRStmt])}\\

\ir\stmt & ::= & \irid \ \verb+=+ \ \ir\expr &
 \mtt{IRExprStmt(val lhs:~IRId, val right:~IRExpr, val ref:~Boolean)}\\

&\mid& \irid \ \verb+=+ \ {\sf delete}\ \irid
& \mtt{IRDelete(val lhs:~IRId, val id:~IRId)}\\

 &\mid& \irid \ \verb+=+ \ {\sf delete}\ \irid\verb+[+\irid\verb+]+
 & \mtt{IRDeleteProp(val lhs:~IRId, val obj:~IRId, val index:~IRExpr)}\\

 &\mid& \irid\verb+[+\irid\verb+] =+ \ \irexpr & \mtt{IRStore(val obj:~IRId, val index:~IRExpr, val rhs:~IRExpr)}\\
 &\mid& \irid \ \verb+=+ \ \verb+{+ (\ir\member\verb+,+)^* \verb+}+
 & \mtt{IRObject(val lhs:~IRId, val members:~List[IRMember],}\\
&&&\mtt{\phantom{IRObject(}val proto:~Option[IRId])}\\
 &\mid& \irid \ \verb+=+ \ \verb+[+ (\irexpr\verb+,+)^* \verb+]+ & \mtt{IRArray(val lhs:~IRId, val elements:~List[Option[IRExpr]])}\\
&&&\mtt{IRArgs(val lhs:~IRId, val elements:~List[Option[IRExpr]])}\\

 &\mid& \irid \ \verb+=+ \ \irid\verb+(+\irid\verb+,+\irid\verb+)+
& \mtt{IRCall(val lhs:~IRId, val fun:~IRId, val thisB:~IRId,}\\
&&&\mtt{\phantom{IRCall(}val args:~IRId)}\\
 &\mid& \irid \ \verb+=+ \ \irid\verb+(+\irid(\verb+,+\irid)^?\verb+)+
& \mtt{IRInternalCall(val lhs:~IRId, val fun:~IRId, val first:~IRExpr,}\\
&&&\mtt{\phantom{IRInternalCall(}val second:~Option[IRId])}\\
&&&{\inblue \mtt{toObject}, \mtt{toNumber}, \mtt{isObject},
\mtt{getBase}, \mtt{iteratorInit},}\\
&&&{\inblue \mtt{iteratorHasNext}, \mtt{iteratorKey}}\\

 &\mid& \irid \ \verb+=+ \ {\sf new}\ \irid\verb+(+(\irid\verb+,+)^*\verb+)+
 & \mtt{IRNew(val lhs:~IRId, val fun:~IRId, val args:~List[IRId])}\\
 &\mid& \irid \ \verb+=+ \ {\sf function} \ \ir{f} \verb+(+\irid\verb+,+\irid\verb+) {+ \ir\stmt^* \verb+}+
& \mtt{IRFunExpr(val lhs:~IRId, val fun:~IRFunctional)}\\
&&&\mtt{IRFunctional(val fromSource:~Boolean, val name:~IRId,}\\
&&&\mtt{\phantom{IRFunctional(}val params:~List[IRId], val args:~List[IRStmt],}\\
&&&\mtt{\phantom{IRFunctional(}val fds:~List[IRFunDecl],}\\
&&&\mtt{\phantom{IRFunctional(}val vds:~List[IRVarStmt], val body:~List[IRStmt])}\\

 &\mid& {\sf function} \ \ir{f} \verb+(+\irid\verb+,+\irid\verb+) {+ \ir\stmt^* \verb+}+
 & \mtt{IRFunDecl(val ftn:~IRFunctional)}\\

 &\mid& \irid \ \verb+=+ \ {\sf eval}\verb+(+\ir\expr\verb+)+ & \mtt{IREval(val lhs:~IRId, val arg:~IRExpr)}\\
 &\mid& {\sf break} \ \irid & \mtt{IRBreak(val label:~IRId)}\\
 &\mid& {\sf return} \ \irexpr^?& \mtt{IRReturn(val expr:~Option[IRExpr])}\\
 &\mid& {\sf with} \ \verb+(+\irid\verb+)+ \ \ir\stmt & \mtt{IRWith(val id:~IRId, val stmt:~IRStmt)}\\
 & \mid & \ir{l} \; \verb+: {+ \; \ir\stmt \; \verb+}+
 & \mtt{IRLabelStmt(val label:~IRId, val stmt:~IRStmt)}\\
 &\mid& {\sf var} \ \irid& \mtt{IRVarStmt(val lhs:~IRId, val fromParam:~Boolean)}\\

 &\mid& {\sf throw} \ \irexpr& \mtt{IRThrow(val expr:~IRExpr)}\\
 &\mid& {\ir\stmt}^*& \mtt{IRSeq(val stmts:~List[IRStmt])}\\
 &\mid& {\sf if} \ \verb+(+\irexpr\verb+)+\ {\sf then} \ \ir\stmt \ ({\sf else} \ \ir\stmt)^?
& \mtt{IRIf(val expr:~IRExpr, val trueB:~IRStmt,}\\
&&&\mtt{\phantom{IRIf(}val falseb:~Option[IRStmt])}\\

 &\mid& {\sf while} \ \verb+(+\irexpr\verb+)+\ \ir\stmt& \mtt{IRWhile(val cond:~IRExpr, val body:~IRStmt)}\\
 &\mid& {\sf try} \ \verb+{+ \ir\stmt \verb+}+ \
({\sf catch} \ \verb+(+\irid\verb+){+ \ir\stmt \verb+}+)^?
& \mtt{IRTry(val body:~IRStmt, val name:~Option[IRId],}\\
&& \phantom{{\sf try} \{ \ir\stmt \}\ \ \ }
({\sf finally} \ \verb+{+ \ir\stmt \verb+}+)^?
&\mtt{\phantom{IRTry(}val catchB:~Option[IRStmt], finallyB:~Option[IRStmt])}\\
&\mid& \open {\ir\stmt}^* \close & \mtt{IRStmtUnit(List[IRStmt] stmts)}\\
\end{array}
\]

\[
\begin{array}{llll}
\ir\expr &::=&
 \irexpr \ \inop \irexpr & \mtt{IRBin(val first:~IRExpr, val op:~IROp, val second:~IRExpr)}\\
 &\mid& \preop \irexpr & \mtt{IRUn(val op:~IROp, val expr:~IRExpr)}\\
 &\mid& \irid\verb+[+\ir\expr\verb+]+ & \mtt{IRLoad(val obj:~IRId, val index:~IRExpr)}\\
 &\mid& \irid& \mtt{IRUserId(val global:~Boolean, val isWith:~Boolean)}\\
 &\mid& \newvar{x}& \mtt{IRTmpId(val global:~Boolean)}\\
 &\mid& \ir\num & \mtt{IRNumber(val text:~String, val num:~Double)}\\
 &\mid& \ir\str & \mtt{IRString(val str:~String)}\\
 &\mid& {\sf true} & \mtt{IRBool(val bool:~Boolean)}\\
 &\mid& {\sf false} & \mtt{IRBool(val bool:~Boolean)}\\
 &\mid& {\sf undefined} & \mtt{IRUndef()}\\
 &\mid& {\sf null} & \mtt{IRNull()}\\
 &\mid& {\sf this} & \mtt{IRThis()}\\\\

\ir\member &::=& \irid \ \verb+:+ \ \irexpr & \mtt{IRField(val prop:~IRId, val expr:~IRExpr)}\\
 &\mid& {\tt get}\ \ir{f} \verb+(+\irid\verb+,+\irid\verb+) {+ \ir\stmt^* \verb+}+
 &\mtt{IRGetProp(val ftn:~IRFunctional)}\\
 &\mid& {\tt set}\ \ir{f} \verb+(+\irid\verb+,+\irid\verb+) {+ \ir\stmt^* \verb+}+
 &\mtt{IRSetProp(val ftn:~IRFunctional)}\\

\end{array}
\]

Assumptions and notations:
\begin{itemize}
\item Functions and variables are hoisted to their closest enclosing functions
or the top level via {\tt Hoister}.
\item Identifiers and labels that exist in the source program,
except when they appear at top level or within the {\tt with} statement,
are already disambiguated via {\tt Disambiguator},
so that they have unique names.
\item We use $\env$ to disambiguate the generated labels and temporary variables in the AST to IR translation.
For the presentation brevity, we simply add the newly generated names to $\env$.
\begin{itemize}
\item In the actual implementation, we need to create a unique id for each generated name and
add the binding information from the general name to the unique id to $\env$.
For example, when we say ``$\env; \newvar{break}$'',
we actually create a unique id for $\newvar{break}$, say $\newvar{break}_{42}$, and add it to $\env$ as $\env; \newvar{break} \mapsto \newvar{break}_{42}$.
When we look up the environment by $\env(\newvar{break})$, the unique $\newvar{break}_{42}$ is returned.
\item In the scope when the generated name is created, we don't add it to the environment but use the unique id instead of the general name.
For example, when we say ``$\newvar{eq}\ \verb+=+\ \env(\newvar{val}) \verb+===+ \newvar{break};$'',
we create a unique id for \newvar{eq}, say $\newvar{eq}_{910157}$, and it is acually
``$\newvar{eq}_{910157}\ \verb+=+\ \env(\newvar{val}) \verb+===+ \newvar{break}_{42};$''.
\item To be clear, we use blue for the binding sites of such names and red for the use sites of such names.
\end{itemize}
\item We denote a list as a possibly empty, semicolon-separated sequence, enclosed by $\langle$ and $\rangle$.
\item We denote a series of list appends as superscripted $*$ such as $\stmt^*$.
\item We denote a fresh variable name as $\newvar{}$ and its variants.
\item We abuse our notations by mixing semicolon-separated sequences and lists.
\item We use the following:\\
\verb+===+, {\sf \ensuremath{\diamond}toObject}, {\sf \ensuremath{\diamond}toNumber}, {\sf \ensuremath{\diamond}isObject},
{\sf \ensuremath{\diamond}iteratorInit}, {\sf \ensuremath{\diamond}iteratorHasNext}, {\sf \ensuremath{\diamond}iteratorNext},
% {\sf startsWith},
{\sf \ensuremath{\diamond}global}, {\sf \ensuremath{\diamond}getBase}
\item To denote an AST-level statement granularity in the translated IR statements,
we use {\tt IRStmtUnit} which is represented as green angle brackets {\ingreen $\open\ \close$} in this document.
To reduce the number of temporary variables, we use global variables to denote constants such as {\sf 1} and
{\sf true} which is represented in green {\ingreen\sf 1} and  {\ingreen\sf true} in this document.
\item We wrap a possibly identical assignment with a box so that the actual implementation, {\tt Translator}, can eliminate identical assignments.
\end{itemize}
