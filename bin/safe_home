#!/bin/bash

################################################################################
#    Copyright (c) 2016, KAIST.
#    All rights reserved.
#
#    Use is subject to license terms.
#
#    This distribution may include materials developed by third parties.
################################################################################

# The following code implements auto-homing, if no home is explicitly set

# if SAFE home is not set
if [ -z "$SAFE_HOME" ]; then
  cmd=$0
  emptyifslash=${cmd##*/*}
  # if the command contains any slashes at all
  if [ -z "$emptyifslash" ]; then
    # slash occurs in name, use as is
    true;
  else
    # no slash
    cmd="`which $cmd`"
  fi
  # if the command that we found resolves to a symbolic link, try to follow
  if [ -L $cmd ]; then
     READLINK=""
     if [ -e /bin/readlink ]; then
        # Linux
        READLINK=/bin/readlink
     elif [ -e /usr/bin/readlink ]; then
        # MacOS
        READLINK=/usr/bin/readlink
     else
       echo "You need to set SAFE_HOME to the directory containing SAFE"
       echo "The target of the symbolic link could not be followed."
       exit 1
     fi
     # Follow the link, figure out if it is absolute or relative.
     target="`$READLINK $cmd`"
     emptyifslash=${target##/*}
     # if absolute (begins with /)
     if [ -z "$emptyifslash" ]; then
       cmd=$target
     else
       cmd=${cmd%/*}/$target
     fi
     # echo Symlink resolves to $cmd
  fi
  SAFE_HOME="${cmd%/*}/.."
  SAFE_HOME="`cd "$SAFE_HOME"; pwd`"
  echo "Guessing SAFE_HOME=$SAFE_HOME" 1>&2
fi

if [ -e "${SAFE_HOME}/bin/safe" ]; then
  true
else
  echo "SAFE_HOME should be the name of the directory including bin/safe"
  echo "instead of '$SAFE_HOME'"
  exit 1
fi

echo "$SAFE_HOME"
